<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Twitch !First Game</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Animation Styles -->
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden; /* Prevent scrollbars in OBS */
        }

        .obs-transparent {
            background-color: transparent !important;
        }

        /* Pop In Animation */
        @keyframes popIn {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            80% { transform: scale(1.1) rotate(5deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .animate-pop-in {
            animation: popIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        /* Shine effect */
        .shine-container {
            position: relative;
            overflow: hidden;
        }
        .shine-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.3), transparent);
            transform: skewX(-25deg);
            animation: shine 3s infinite;
        }
        @keyframes shine {
            100% { left: 200%; }
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen w-screen flex flex-col items-center justify-center">

    <div id="root" class="w-full h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- CONSTANTS ---
        const SHOW_DURATION_MS = 3 * 60 * 1000; // 3 Minutes visible
        const HIDE_DURATION_MS = 30 * 60 * 1000; // 30 Minutes hidden
        
        const DEFAULT_IGNORED_USERS = [
            'nightbot', 'streamelements', 'streamlabs', 'moobot', 'wizebot', 'fossabot'
        ];

        // Default Customization
        const DEFAULT_CONFIG = {
            accentColor: '#9333ea', // Purple-600
            emoji: 'ðŸ‘‘',
            bottomText: 'WAS FIRST!',
            textColor: '#fde047' // Yellow-300
        };

        function App() {
            // Helper to get params or local storage
            const getInitialState = (key, fallback) => {
                const params = new URLSearchParams(window.location.search);
                if (params.has(key)) return params.get(key);
                return localStorage.getItem(key) || fallback;
            };

            // Basic Config
            const [channel, setChannel] = useState(getInitialState('channel', ''));
            const [command, setCommand] = useState(getInitialState('command', '!first'));
            const [ignoredUsers, setIgnoredUsers] = useState(localStorage.getItem('ignoredUsers') || DEFAULT_IGNORED_USERS.join(', '));
            
            // UI State
            const [showAdmin, setShowAdmin] = useState(false);
            const [copySuccess, setCopySuccess] = useState('');

            // Customization Config (Check URL first, then LocalStorage, then Default)
            const [customConfig, setCustomConfig] = useState(() => {
                const params = new URLSearchParams(window.location.search);
                // If customization is in URL, prefer that (for OBS link sharing)
                if (params.has('accent')) {
                    return {
                        accentColor: decodeURIComponent(params.get('accent')),
                        emoji: decodeURIComponent(params.get('emoji') || 'ðŸ‘‘'),
                        bottomText: decodeURIComponent(params.get('text') || 'WAS FIRST!'),
                        textColor: decodeURIComponent(params.get('TextColor') || '#fde047')
                    };
                }
                const saved = localStorage.getItem('customConfig');
                return saved ? JSON.parse(saved) : DEFAULT_CONFIG;
            });

            // App State
            const [connected, setConnected] = useState(false);
            const [winner, setWinner] = useState(null); 
            const [gameState, setGameState] = useState('hunting'); 
            const [error, setError] = useState(null);
            
            // Refs
            const ws = useRef(null);
            const audioRef = useRef(null);
            const isAutoModeRef = useRef(false);
            const reconnectTimeoutRef = useRef(null);

            // Save config
            useEffect(() => {
                localStorage.setItem('channel', channel);
                localStorage.setItem('command', command);
                localStorage.setItem('ignoredUsers', ignoredUsers);
                localStorage.setItem('customConfig', JSON.stringify(customConfig));
            }, [channel, command, ignoredUsers, customConfig]);

            // Audio Player
            const playSound = useCallback(() => {
                if (audioRef.current) {
                    audioRef.current.volume = 0.5;
                    audioRef.current.currentTime = 0;
                    audioRef.current.play().catch(e => console.log("Audio play failed (interaction needed first):", e));
                }
            }, []);

            // API Calls
            const fetchAvatarDecAPI = async (username) => {
                try {
                    const response = await fetch(`https://decapi.me/twitch/avatar/${username}`);
                    if (!response.ok) throw new Error('DecAPI fetch failed');
                    return await response.text();
                } catch (err) {
                    return "https://static-cdn.jtvnw.net/user-default-pictures-uv/cdd517fe-def4-11e9-948e-784f43822e80-profile_image-300x300.png";
                }
            };

            const parseTags = (rawTags) => {
                const tags = {};
                rawTags.split(';').forEach(tag => {
                    const [key, value] = tag.split('=');
                    tags[key] = value;
                });
                return tags;
            };

            // --- GAME LOOP LOGIC ---
            useEffect(() => {
                let timer;
                if (gameState === 'showing') {
                    playSound();
                    console.log(`Showing winner for ${SHOW_DURATION_MS/1000}s`);
                    timer = setTimeout(() => {
                        setGameState('cooldown');
                    }, SHOW_DURATION_MS);
                } else if (gameState === 'cooldown') {
                    console.log(`Hidden for ${HIDE_DURATION_MS/1000}s...`);
                    timer = setTimeout(() => {
                        setGameState('showing');
                    }, HIDE_DURATION_MS);
                }
                return () => clearTimeout(timer);
            }, [gameState, playSound]);

            // --- EVENTS ---
            const handleManualReset = () => {
                setWinner(null);
                setGameState('hunting');
            };

            const handleWinnerFound = (username) => {
                console.log(`Winner found: ${username}`);
                setWinner({ username, avatarUrl: null });
                setGameState('showing');

                (async () => {
                    const lowerUser = username.toLowerCase();
                    const avatarUrl = await fetchAvatarDecAPI(lowerUser);
                    setWinner(prev => prev ? ({ ...prev, avatarUrl }) : null);
                })();
            };

            // --- WEBSOCKET CONNECTION ---
            const connect = useCallback(() => {
                if (!channel) return setError("Please enter a channel name.");
                setError(null);
                
                // Update Browser URL so user can see/copy it
                const params = new URLSearchParams();
                params.set('channel', channel);
                if (command !== '!first') params.set('command', command);
                // Save styles to URL
                params.set('accent', customConfig.accentColor);
                params.set('emoji', customConfig.emoji);
                params.set('text', customConfig.bottomText);
                params.set('TextColor', customConfig.textColor);
                
                const newUrl = `${window.location.pathname}?${params.toString()}`;
                window.history.pushState({}, '', newUrl);

                if (reconnectTimeoutRef.current) clearTimeout(reconnectTimeoutRef.current);

                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
                ws.current = socket;

                socket.onopen = () => {
                    console.log('Connected to Twitch');
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan12345');
                    socket.send(`JOIN #${channel.toLowerCase()}`);
                    setConnected(true);
                };

                socket.onmessage = (event) => {
                    const data = event.data;
                    if (data.startsWith('PING')) { socket.send('PONG :tmi.twitch.tv'); return; }

                    if (data.includes('PRIVMSG')) {
                        const parts = data.split(' ');
                        const privMsgIndex = parts.indexOf('PRIVMSG');
                        
                        if (privMsgIndex !== -1) {
                            let msgContent = parts.slice(privMsgIndex + 2).join(' ');
                            if (msgContent.startsWith(':')) msgContent = msgContent.substring(1);
                            msgContent = msgContent.trim().toLowerCase();

                            let tags = {};
                            let username = "Unknown";
                            if (data.startsWith('@')) {
                                tags = parseTags(data.substring(1, data.indexOf(' :')));
                                username = tags['display-name'] || username;
                            }

                            if (msgContent === '!resetfirst') {
                                const badges = tags['badges'] || "";
                                if (badges.includes('broadcaster') || badges.includes('moderator')) {
                                    handleManualReset();
                                    return; 
                                }
                            }

                            setGameState(currentState => {
                                if (currentState !== 'hunting') return currentState; 

                                if (msgContent.startsWith(command.toLowerCase())) {
                                    const lowerUser = username.toLowerCase();
                                    const ignoreList = ignoredUsers.toLowerCase().split(',').map(u => u.trim());

                                    if (!ignoreList.includes(lowerUser)) {
                                        handleWinnerFound(username);
                                        return 'showing'; 
                                    }
                                }
                                return currentState;
                            });
                        }
                    }
                };

                socket.onerror = (err) => {
                    console.error("Socket Error", err);
                    setConnected(false);
                };

                socket.onclose = () => {
                    console.log("Disconnected");
                    setConnected(false);
                    if (isAutoModeRef.current) {
                        reconnectTimeoutRef.current = setTimeout(() => connect(), 5000);
                    }
                };
            }, [channel, command, ignoredUsers, customConfig]);

            // Auto-Connect Effect
            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                // Auto connect if channel present AND we didn't just open the admin panel manually
                if (params.has('channel')) {
                    isAutoModeRef.current = true;
                    connect();
                }
                return () => {
                    if (ws.current) ws.current.close();
                    if (reconnectTimeoutRef.current) clearTimeout(reconnectTimeoutRef.current);
                };
            }, [connect]);

            const disconnect = () => {
                isAutoModeRef.current = false;
                if (ws.current) { ws.current.close(); ws.current = null; }
                setConnected(false);
                setWinner(null);
                setGameState('hunting');
                // Remove channel param to stop auto-connect on refresh if manually stopped
                const newUrl = window.location.pathname;
                window.history.pushState({}, '', newUrl);
            };

            const testWinner = () => {
                setGameState(curr => {
                   if(curr !== 'hunting') return curr;
                   handleWinnerFound("Test_User"); 
                   return 'showing';
                });
            };
            
            const generateObsLink = () => {
                const params = new URLSearchParams();
                params.set('channel', channel);
                if (command !== '!first') params.set('command', command);
                params.set('accent', customConfig.accentColor);
                params.set('emoji', customConfig.emoji);
                params.set('text', customConfig.bottomText);
                params.set('TextColor', customConfig.textColor);
                
                const url = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
                
                navigator.clipboard.writeText(url).then(() => {
                    setCopySuccess('Link Copied! Paste into OBS Browser Source.');
                    setTimeout(() => setCopySuccess(''), 3000);
                });
            };

            // Effect to handle body transparency for OBS
            useEffect(() => {
                if ((connected || isAutoModeRef.current)) {
                    document.body.classList.add('obs-transparent');
                } else {
                    document.body.classList.remove('obs-transparent');
                }
            }, [connected]);

            // Helper for Color styles
            const getTextStyle = () => ({
                color: customConfig.textColor,
                borderColor: customConfig.accentColor
            });

            // --- RENDER ---

            // 1. SETTINGS / ADMIN SCREEN
            if (!connected && !isAutoModeRef.current) {
                return (
                    <div className="bg-gray-800 p-8 rounded-xl shadow-2xl max-w-md w-full border border-gray-700 max-h-screen overflow-y-auto">
                        <div className="flex items-center justify-center mb-4">
                            <h1 className="text-3xl font-bold text-white">First! Game</h1>
                        </div>
                        
                        <div className="space-y-4">
                            {/* Basic Settings */}
                            <div className="p-3 bg-gray-900 rounded border border-gray-700 space-y-3">
                                <h3 className="text-sm font-bold text-gray-300 uppercase tracking-wider">Setup</h3>
                                <div>
                                    <label className="block text-xs font-medium text-gray-400">Channel Name</label>
                                    <input type="text" value={channel} onChange={(e) => setChannel(e.target.value)} placeholder="e.g. Ninja" className="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-purple-500" />
                                </div>
                                <div>
                                    <label className="block text-xs font-medium text-gray-400">Command</label>
                                    <input type="text" value={command} onChange={(e) => setCommand(e.target.value)} placeholder="!first" className="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white focus:outline-none focus:border-purple-500" />
                                </div>
                            </div>

                            {/* Toggle Admin */}
                            <button 
                                onClick={() => setShowAdmin(!showAdmin)}
                                className="w-full text-sm bg-gray-700 hover:bg-gray-600 text-white rounded py-2 flex items-center justify-center space-x-2 transition"
                            >
                                <span>{showAdmin ? 'Hide' : 'ðŸŽ¨ Customize Look'}</span>
                            </button>

                            {/* Admin Customization */}
                            {showAdmin && (
                                <div className="p-3 bg-gray-900 rounded border border-gray-700 space-y-3 animate-pop-in">
                                    <h3 className="text-sm font-bold text-purple-400 uppercase tracking-wider">Design</h3>
                                    
                                    <div className="grid grid-cols-2 gap-2">
                                        <div>
                                            <label className="block text-xs font-medium text-gray-400">Accent Color</label>
                                            <div className="flex items-center space-x-2">
                                                <input type="color" value={customConfig.accentColor} onChange={(e) => setCustomConfig({...customConfig, accentColor: e.target.value})} className="w-8 h-8 bg-transparent cursor-pointer rounded border border-gray-600" />
                                                <span className="text-xs text-gray-500">{customConfig.accentColor}</span>
                                            </div>
                                        </div>
                                        <div>
                                            <label className="block text-xs font-medium text-gray-400">Text Color</label>
                                            <div className="flex items-center space-x-2">
                                                <input type="color" value={customConfig.textColor} onChange={(e) => setCustomConfig({...customConfig, textColor: e.target.value})} className="w-8 h-8 bg-transparent cursor-pointer rounded border border-gray-600" />
                                                <span className="text-xs text-gray-500">{customConfig.textColor}</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div>
                                        <label className="block text-xs font-medium text-gray-400">Emoji / Icon</label>
                                        <input type="text" value={customConfig.emoji} onChange={(e) => setCustomConfig({...customConfig, emoji: e.target.value})} className="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white" />
                                    </div>
                                    <div>
                                        <label className="block text-xs font-medium text-gray-400">Bottom Text</label>
                                        <input type="text" value={customConfig.bottomText} onChange={(e) => setCustomConfig({...customConfig, bottomText: e.target.value})} className="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2 text-white" />
                                    </div>
                                    
                                    <div className="text-center p-2 bg-black/50 rounded border border-gray-600">
                                        <p className="text-xs text-gray-400 mb-2">-- Preview --</p>
                                        <div className="flex flex-col items-center scale-75 transform origin-center">
                                            <div className="relative">
                                                <div className="w-24 h-24 rounded-full border-4 bg-gray-700 overflow-hidden" style={{ borderColor: customConfig.accentColor }}>
                                                     <img src="https://static-cdn.jtvnw.net/user-default-pictures-uv/cdd517fe-def4-11e9-948e-784f43822e80-profile_image-300x300.png" className="w-full h-full object-cover" />
                                                </div>
                                                <div className="absolute -top-3 left-1/2 transform -translate-x-1/2 text-2xl">{customConfig.emoji}</div>
                                            </div>
                                            <div className="mt-2 bg-black/80 px-4 py-1 rounded-full border shadow-lg font-bold" style={{ color: customConfig.textColor, borderColor: customConfig.accentColor }}>
                                                {customConfig.bottomText}
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            )}

                            <div className="flex flex-col space-y-2 pt-2">
                                <button onClick={connect} className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 rounded shadow-lg transform active:scale-95 transition">Start Listening</button>
                                
                                {channel && (
                                    <button onClick={generateObsLink} className="w-full bg-gray-700 hover:bg-gray-600 text-gray-200 font-bold py-2 rounded text-sm transition">
                                        ðŸ”— Copy Link for OBS
                                    </button>
                                )}
                                {copySuccess && <p className="text-green-400 text-xs text-center">{copySuccess}</p>}
                            </div>
                        </div>
                    </div>
                );
            }

            // 2. CONNECTED SCREEN
            return (
                <div className="relative w-full h-full flex items-center justify-center">
                    {/* Control Bar */}
                    <div className="absolute top-0 left-0 w-full p-2 opacity-0 hover:opacity-100 transition-opacity duration-300 z-50 flex space-x-2 bg-black/50 backdrop-blur-sm">
                        <button onClick={handleManualReset} className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm">Force Reset</button>
                        <button onClick={testWinner} className="bg-gray-600 hover:bg-gray-700 text-white px-3 py-1 rounded text-sm">Test Win</button>
                        <button onClick={disconnect} className="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm">Stop / Config</button>
                        <span className="text-gray-300 text-sm ml-auto flex items-center">
                            State: <span className={`font-bold mx-1 ${gameState === 'hunting' ? 'text-green-400' : gameState === 'showing' ? 'text-purple-400' : 'text-red-400'}`}>{gameState.toUpperCase()}</span>
                        </span>
                    </div>

                    {/* Winner Display */}
                    {gameState === 'showing' && winner && (
                        <div className="flex flex-col items-center animate-pop-in">
                            <div className="relative group">
                                {/* Glow Ring */}
                                <div className="absolute -inset-1 rounded-full blur opacity-75 animate-pulse" style={{ background: customConfig.accentColor }}></div>
                                
                                {/* Image */}
                                <div className="relative w-48 h-48 md:w-64 md:h-64 rounded-full overflow-hidden border-4 shadow-2xl bg-gray-800 shine-container" style={{ borderColor: customConfig.accentColor }}>
                                    {winner.avatarUrl ? (
                                        <img src={winner.avatarUrl} alt={winner.username} className="w-full h-full object-cover" />
                                    ) : (
                                        <div className="w-full h-full flex items-center justify-center bg-gray-800"><div className="animate-spin h-10 w-10 border-4 border-white rounded-full border-t-transparent"></div></div>
                                    )}
                                </div>
                                
                                {/* Emoji */}
                                <div className="absolute -top-6 left-1/2 transform -translate-x-1/2 drop-shadow-lg text-5xl">
                                    {customConfig.emoji}
                                </div>
                            </div>

                            {/* Username */}
                            <div className="mt-6 bg-gray-900/90 text-white px-8 py-2 rounded-xl border border-white/20 shadow-xl backdrop-blur-md">
                                <h2 className="text-3xl font-black uppercase tracking-wider drop-shadow-sm" style={{ 
                                    background: `-webkit-linear-gradient(left, #fff, ${customConfig.textColor})`, 
                                    WebkitBackgroundClip: 'text',
                                    WebkitTextFillColor: 'transparent'
                                }}>
                                    {winner.username}
                                </h2>
                            </div>
                            
                            {/* Custom Text */}
                            <div className="mt-2 bg-black/60 font-bold text-xl px-6 py-1 rounded-full border shadow-lg backdrop-blur-sm tracking-widest" style={getTextStyle()}>
                                {customConfig.bottomText}
                            </div>
                        </div>
                    )}

                    {/* Auto-Connect Loading State */}
                    {(!connected && isAutoModeRef.current) && (
                         <div className="flex flex-col items-center justify-center h-full">
                            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500 mb-4"></div>
                            <p className="text-gray-400">Connecting to {channel}...</p>
                            <button onClick={disconnect} className="mt-4 text-sm text-red-400 hover:text-red-300 underline">Cancel Auto-Connect</button>
                        </div>
                    )}

                    {gameState === 'hunting' && <div className="text-center opacity-0">Waiting...</div>}

                    <audio ref={audioRef} src="https://assets.mixkit.co/active_storage/sfx/2000/2000-preview.mp3" preload="auto"></audio>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>