<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salamander WebTuber v4.2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/comfy.js@latest/dist/comfy.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #111; 
            font-family: 'Segoe UI', sans-serif;
        }
        
        /* --- STAGE (The Scene) --- */
        #stage {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            overflow: hidden;
            background-color: #00b140; 
        }

        /* Interactive Elements Wrappers */
        .interactive-layer {
            position: absolute;
            transform-origin: center center;
            cursor: grab;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            /* FIX: Ensure this layer receives clicks even if parent has pointer-events: none */
            pointer-events: auto; 
        }
        .interactive-layer:active { cursor: grabbing; }
        .interactive-layer.locked { cursor: default; pointer-events: none; }

        /* Background specific */
        #bg-wrapper {
            top: 50%; left: 50%;
            width: 100vw; height: 100vh;
            z-index: 0;
        }
        #bg-img {
            width: 100%; height: 100%;
            object-fit: cover;
            pointer-events: none;
        }

        /* Avatar specific */
        #avatar-wrapper {
            top: 50%; left: 50%;
            width: 400px; height: 400px;
            z-index: 10;
            transform: translate(-50%, -50%) scale(1); 
        }

        /* The Physics Container (Inside wrapper) */
        #avatar-physics {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            transform-origin: bottom center;
            /* Container shouldn't block clicks to things behind it, but children need events */
            pointer-events: none; 
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
        }

        #avatar-img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            pointer-events: none;
            transition: filter 0.1s;
        }

        /* 3. Pinned Props (Attached to Avatar Physics) */
        .prop-pinned {
            z-index: 15;
            top: 20%; left: 50%; 
            width: 150px; height: 150px;
        }
        .prop-pinned img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }

        /* 4. Static Props (Foreground / Desk) */
        #prop-static-wrapper {
            top: 80%; left: 50%;
            width: 600px; height: 300px;
            z-index: 30; /* Default Front */
            transform: translate(-50%, -50%) scale(1);
        }
        #prop-static-img { width: 100%; height: 100%; object-fit: contain; pointer-events: none; }

        /* Swear Symbols */
        .swear-symbol {
            position: absolute;
            font-weight: 900;
            color: #ef4444; 
            text-shadow: 2px 2px 0px #000;
            font-family: 'Comic Sans MS', sans-serif;
            opacity: 1;
            pointer-events: none;
            z-index: 20;
        }
        #swear-layer {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        /* --- UI CONTROLS --- */
        #controls {
            position: absolute;
            top: 10px; left: 10px;
            background: rgba(17, 24, 39, 0.95);
            padding: 20px;
            border-radius: 12px;
            color: white;
            width: 360px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid #374151;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        #controls.hidden {
            display: block !important;
            transform: translateX(-400px);
            opacity: 0;
            pointer-events: none;
        }

        #controls::-webkit-scrollbar { width: 6px; }
        #controls::-webkit-scrollbar-track { background: #1f2937; }
        #controls::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }

        .control-group { margin-bottom: 16px; border-bottom: 1px solid #374151; padding-bottom: 12px; }
        .control-group:last-child { border-bottom: none; }
        .control-group label { display: block; font-size: 11px; text-transform: uppercase; font-weight: 700; margin-bottom: 8px; color: #a5b4fc; letter-spacing: 0.05em; }
        
        input[type="range"] { width: 100%; accent-color: #a855f7; height: 4px; background: #4b5563; border-radius: 2px; }
        
        /* FORCE VISIBILITY */
        input[type="text"] { 
            background-color: #374151 !important; 
            color: #ffffff !important; 
            border: 1px solid #4b5563; 
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            outline: none;
            width: 100%;
        }
        input[type="text"]:focus { border-color: #a855f7; }

        select { 
            width: 100%;
            background-color: #ffffff !important; 
            color: #000000 !important; 
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 4px;
            font-size: 12px;
            margin-bottom: 8px;
            outline: none;
        }
        select:focus { border-color: #a855f7; }
        select option { background-color: #ffffff; color: #000000; }
        
        .file-btn {
            background: rgba(255,255,255,0.05); border: 1px dashed #6b7280;
            padding: 8px; border-radius: 6px; text-align: center; cursor: pointer; font-size: 12px; color: #d1d5db; transition: all 0.2s;
            flex: 1; /* For flex layouts */
        }
        .file-btn:hover { border-color: #a855f7; background: rgba(168, 85, 247, 0.1); color: white; }

        .btn-clear {
            background: rgba(153, 27, 27, 0.3); border: 1px dashed #7f1d1d;
            color: #fca5a5; width: 32px; display: flex; align-items: center; justify-content: center;
            border-radius: 6px; cursor: pointer; transition: all 0.2s;
        }
        .btn-clear:hover { background: rgba(185, 28, 28, 0.6); color: white; border-color: #ef4444; }

        .btn-layer {
            background: rgba(31, 41, 55, 0.8); border: 1px solid #4b5563;
            color: #9ca3af; width: 40px; display: flex; align-items: center; justify-content: center;
            border-radius: 6px; cursor: pointer; transition: all 0.2s; font-size: 10px; font-weight: bold;
        }
        .btn-layer:hover { border-color: #a855f7; color: white; }
        .btn-layer.back { background: rgba(17, 24, 39, 0.8); border-color: #374151; color: #6b7280; }

        .toggle-btn { @apply text-xs py-1 px-3 rounded border border-gray-600 bg-gray-800 text-gray-300 transition hover:bg-gray-700 cursor-pointer; }
        .toggle-btn.active { @apply bg-purple-600 border-purple-500 text-white; }

        .mode-btn { @apply flex-1 py-2 text-center text-xs font-bold rounded border border-gray-600 bg-gray-800 text-gray-400 transition cursor-pointer hover:bg-gray-700 relative overflow-hidden; }
        .mode-btn.active { @apply bg-purple-600 border-purple-500 text-white shadow-lg shadow-purple-900/50; }
        .key-badge { @apply absolute top-0 right-0 bg-gray-900 text-[9px] px-1 text-gray-400 rounded-bl opacity-70; }

        #hint-overlay {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: #ccc; padding: 5px 15px; border-radius: 20px;
            font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 500;
        }
        .show-hint #hint-overlay { opacity: 1; }

        details summary { cursor: pointer; list-style: none; font-size: 12px; color: #9ca3af; outline: none; }
        details summary::-webkit-details-marker { display: none; }
        details summary:hover { color: #fff; }
        details[open] summary { margin-bottom: 10px; }
        
        .key-bind-input { 
            width: 32px;
            text-align: center;
            text-transform: uppercase;
            cursor: pointer;
            background-color: #374151 !important; 
            color: white !important; 
            border: 1px solid #4b5563;
            border-radius: 4px;
            font-size: 12px;
            padding: 2px 0;
        }
        .key-bind-input:focus { border-color: #a855f7; background-color: #4c1d95 !important; }
    </style>
</head>
<body class="show-hint">

    <!-- The Stage -->
    <div id="stage">
        
        <!-- 1. Background -->
        <div id="bg-wrapper" class="interactive-layer">
            <img id="bg-img" src="" style="display:none;">
        </div>

        <!-- 2. Avatar Group (Z-Index 10) -->
        <div id="avatar-wrapper" class="interactive-layer">
            <!-- Physics Container (Bounces/Squashes) -->
            <div id="avatar-physics">
                <img id="avatar-img" src="https://cdn3.emoji.gg/emojis/8422-blobcat-coffee.png">
                
                <!-- Pinned Prop (Moves WITH Physics) - Z-Index 15 -->
                <div id="prop-pinned-wrapper" class="interactive-layer prop-pinned" style="display:none;">
                    <img id="prop-pinned-img" src="">
                </div>

                <div id="swear-layer" class="absolute inset-0 pointer-events-none"></div>
            </div>
        </div>

        <!-- 3. Static Prop (Foreground / Desk) - Z-Index 30 or 5 -->
        <div id="prop-static-wrapper" class="interactive-layer" style="display:none;">
            <img id="prop-static-img" src="">
        </div>

    </div>

    <!-- Hint -->
    <div id="hint-overlay">Drag to Move â€¢ Wheel to Resize â€¢ 'H' to Hide UI</div>

    <!-- Controls -->
    <div id="controls">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-lg font-bold text-white">Web<span class="text-purple-400">Tuber</span> <span class="text-xs bg-purple-900 px-1 rounded">v4.2</span></h1>
            <button id="btn-hide" class="text-gray-400 hover:text-white text-sm" title="Press 'H' to toggle">Hide UI âœ•</button>
        </div>

        <!-- Profile Manager -->
        <div class="control-group">
            <label>Data Management</label>
            <div class="text-[10px] text-gray-400 mb-2">Settings auto-save to browser storage.</div>
            <div class="flex gap-2">
                <button onclick="exportProfile()" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white text-xs py-2 rounded">â¬‡ Export Backup</button>
                <div class="flex-1 relative">
                    <button class="w-full bg-gray-700 hover:bg-gray-600 text-white text-xs py-2 rounded" onclick="document.getElementById('input-load').click()">â¬† Import Backup</button>
                    <input type="file" id="input-load" class="hidden" accept=".json">
                </div>
            </div>
            <button onclick="resetData()" class="w-full mt-2 bg-red-900/50 hover:bg-red-800 text-red-200 text-xs py-1 rounded border border-red-800">âš  Wipe Data / Reset</button>
        </div>

        <!-- Audio Setup -->
        <div class="control-group">
            <label>Audio Setup</label>
            <select id="audio-device-select"><option value="">Default Microphone</option></select>
            <button id="btn-start" class="w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 rounded-lg shadow-lg shadow-purple-900/30 transition flex items-center justify-center gap-2">
                <span>ðŸŽ¤</span> Start Mic
            </button>
        </div>

        <!-- Mode Switcher -->
        <div class="control-group">
            <label>Expression Switcher</label>
            <div class="flex gap-1 mb-2">
                <div id="mode-1" class="mode-btn active" onclick="setMode(1)">Normal<div class="key-badge" id="badge-1">1</div></div>
                <div id="mode-2" class="mode-btn" onclick="setMode(2)">Happy<div class="key-badge" id="badge-2">2</div></div>
                <div id="mode-3" class="mode-btn" onclick="setMode(3)">Angry<div class="key-badge" id="badge-3">3</div></div>
                <div id="mode-4" class="mode-btn" onclick="setMode(4)">Sad<div class="key-badge" id="badge-4">4</div></div>
            </div>
            <div class="text-[10px] text-gray-500 text-center italic" id="upload-hint">
                Editing: <span id="current-mode-name" class="text-purple-400 font-bold">Normal</span>
            </div>
        </div>

        <div class="control-group">
            <label>Avatar Images (Current Mode)</label>
            <div class="grid grid-cols-2 gap-2">
                <!-- Idle -->
                <div class="flex gap-1">
                    <div class="file-btn" onclick="document.getElementById('input-idle').click()">
                        <span id="label-idle">ðŸ“‚ Idle Frames</span>
                    </div>
                    <!-- Clear Button -->
                    <button class="btn-clear" onclick="clearFrames('idle')" title="Clear Idle">ðŸ—‘</button>
                </div>
                <!-- Talk -->
                <div class="flex gap-1">
                    <div class="file-btn" onclick="document.getElementById('input-talk').click()">
                        <span id="label-talk">ðŸ“‚ Talk Frames</span>
                    </div>
                    <!-- Clear Button -->
                    <button class="btn-clear" onclick="clearFrames('talk')" title="Clear Talk">ðŸ—‘</button>
                </div>
            </div>
            <input type="file" id="input-idle" class="hidden" multiple accept="image/*">
            <input type="file" id="input-talk" class="hidden" multiple accept="image/*">
        </div>

        <!-- PROPS SYSTEM -->
        <div class="control-group">
            <label>Props & Layers</label>
            <div class="grid grid-cols-2 gap-2">
                <!-- Pinned -->
                <div class="flex gap-1">
                    <div class="file-btn" onclick="document.getElementById('input-prop-pinned').click()">
                        <span id="label-prop-pinned">ðŸŽ© Pinned</span>
                    </div>
                    <button class="btn-clear" onclick="clearProp('pinned')" title="Remove Prop">ðŸ—‘</button>
                </div>
                <!-- Static -->
                <div class="flex gap-1">
                    <div class="file-btn" onclick="document.getElementById('input-prop-static').click()">
                        <span id="label-prop-static">ðŸŽ¤ Static</span>
                    </div>
                    <button id="btn-layer-static" class="btn-layer" onclick="toggleStaticLayer()" title="Change Layer: Front/Back">Front</button>
                    <button class="btn-clear" onclick="clearProp('static')" title="Remove Prop">ðŸ—‘</button>
                </div>
            </div>
            <div class="text-[10px] text-gray-500 mt-1">
                <b>Pinned:</b> Bounces with you. <b>Static:</b> Stays in foreground.
            </div>
            <input type="file" id="input-prop-pinned" class="hidden" accept="image/*">
            <input type="file" id="input-prop-static" class="hidden" accept="image/*">
        </div>

        <!-- Input & Integration Settings -->
        <div class="control-group">
            <details>
                <summary class="flex justify-between items-center bg-gray-800 p-2 rounded border border-gray-700">
                    <span>ðŸŽ® Inputs & Integrations</span>
                    <span class="text-[10px]">â–¼</span>
                </summary>
                <div class="pt-3 space-y-3 pl-1">
                    
                    <!-- Keyboard Rebinds -->
                    <div>
                        <div class="text-[10px] uppercase font-bold text-gray-500 mb-2">Keyboard Hotkeys (Focus Required)</div>
                        <div class="grid grid-cols-4 gap-2 text-center">
                            <div><div class="text-[9px] text-gray-400">Normal</div><input type="text" id="bind-1" class="key-bind-input" value="1" readonly></div>
                            <div><div class="text-[9px] text-gray-400">Happy</div><input type="text" id="bind-2" class="key-bind-input" value="2" readonly></div>
                            <div><div class="text-[9px] text-gray-400">Angry</div><input type="text" id="bind-3" class="key-bind-input" value="3" readonly></div>
                            <div><div class="text-[9px] text-gray-400">Sad</div><input type="text" id="bind-4" class="key-bind-input" value="4" readonly></div>
                        </div>
                    </div>

                    <!-- Twitch Integration -->
                    <div class="border-t border-gray-700 pt-2">
                        <div class="text-[10px] uppercase font-bold text-gray-500 mb-2">Twitch Remote (Global Control)</div>
                        <div class="flex gap-2 mb-2">
                            <input type="text" id="twitch-channel" placeholder="Channel Name" class="flex-1">
                            <button id="btn-twitch-connect" class="bg-purple-700 hover:bg-purple-600 text-white text-xs px-3 rounded">Connect</button>
                        </div>
                        <div id="twitch-status" class="text-[10px] text-gray-500 mb-2">Not Connected</div>
                        
                        <div class="grid grid-cols-2 gap-2">
                            <div><span class="text-[9px] text-gray-400">Normal Cmd</span><input type="text" id="cmd-1" value="!normal"></div>
                            <div><span class="text-[9px] text-gray-400">Happy Cmd</span><input type="text" id="cmd-2" value="!happy"></div>
                            <div><span class="text-[9px] text-gray-400">Angry Cmd</span><input type="text" id="cmd-3" value="!angry"></div>
                            <div><span class="text-[9px] text-gray-400">Sad Cmd</span><input type="text" id="cmd-4" value="!sad"></div>
                        </div>
                    </div>

                </div>
            </details>
        </div>

        <div class="control-group">
            <label>Settings</label>
            <div class="space-y-4">
                <div>
                    <div class="flex justify-between text-[10px] text-gray-400 mb-1">
                        <span>Mic Sensitivity</span>
                        <span id="vol-meter" class="text-green-400 font-mono">0</span>
                    </div>
                    <input type="range" id="slider-threshold" min="1" max="100" value="15">
                </div>
                
                <details>
                    <summary class="flex justify-between items-center bg-gray-800 p-2 rounded">
                        <span>ðŸ›  Animation Tuning</span>
                        <span class="text-[10px]">â–¼</span>
                    </summary>
                    <div class="pt-3 space-y-3 pl-1">
                        <div>
                            <div class="flex justify-between text-[10px] text-gray-400 mb-1">
                                <span>Idle Speed (Blink)</span>
                                <span id="speed-idle-val">150ms</span>
                            </div>
                            <input type="range" id="slider-speed-idle" min="50" max="1000" step="10" value="150" dir="rtl">
                        </div>
                        <div>
                            <div class="flex justify-between text-[10px] text-gray-400 mb-1">
                                <span>Talk Speed (Mouth)</span>
                                <span id="speed-talk-val">60ms</span>
                            </div>
                            <input type="range" id="slider-speed-talk" min="20" max="300" step="10" value="60" dir="rtl">
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-[10px] text-gray-400">Randomize Talk Frames</span>
                            <input type="checkbox" id="chk-random-talk" class="accent-purple-500" checked>
                        </div>
                        <div>
                            <div class="flex justify-between text-[10px] text-gray-400 mb-1">
                                <span>Bounce Physics</span>
                            </div>
                            <input type="range" id="slider-bounce" min="0" max="100" value="20">
                        </div>
                    </div>
                </details>
            </div>
        </div>

        <div class="control-group">
            <label>Scene Editor</label>
            <div class="flex gap-2 mb-2">
                <button id="btn-lock" class="toggle-btn w-full flex justify-center items-center gap-2">
                    <span>ðŸ”“</span> Unlocked
                </button>
                <button onclick="resetLayout()" class="toggle-btn w-auto" title="Reset Positions">â†º</button>
            </div>
            
            <div class="flex gap-2 mt-3">
                <button id="btn-toggle-swear" class="toggle-btn flex-1">ðŸ¤¬ Swear</button>
                <button id="btn-toggle-shake" class="toggle-btn flex-1 active">ðŸ«¨ Shake</button>
            </div>
            <div class="mt-2">
                <span class="text-[10px] text-gray-400 block mb-1">Zoom Intensity</span>
                <input type="range" id="slider-zoom" min="100" max="150" value="110">
            </div>
        </div>

        <div class="control-group">
            <label>Background</label>
            <div class="flex items-center gap-1">
                <input type="color" id="bg-color-picker" value="#00b140" class="w-8 h-8 rounded cursor-pointer border-0 bg-transparent p-0">
                <div class="file-btn flex-1" onclick="document.getElementById('input-bg').click()">
                    <span id="label-bg">ðŸ–¼ Upload</span>
                </div>
                <button class="btn-clear" onclick="clearBg()" title="Clear Background">ðŸ—‘</button>
            </div>
            <input type="file" id="input-bg" class="hidden" accept="image/*">
        </div>
    </div>

    <script>
        if (window.location.protocol === 'file:') alert("âš ï¸ Local File Detected. Mic access requires 'localhost' or GitHub Pages.");

        // --- GLOBAL STATE ---
        const state = {
            audioContext: null,
            analyser: null,
            dataArray: null,
            isAnimating: false,
            
            activeMode: 1, 
            modes: {
                1: { name: 'Normal', idle: ["https://cdn3.emoji.gg/emojis/8422-blobcat-coffee.png"], talk: ["https://cdn3.emoji.gg/emojis/9686-blobcat-hyper.gif"] },
                2: { name: 'Happy', idle: [], talk: [] },
                3: { name: 'Angry', idle: [], talk: [] },
                4: { name: 'Sad', idle: [], talk: [] }
            },
            hotkeys: { 1: 'Digit1', 2: 'Digit2', 3: 'Digit3', 4: 'Digit4' },
            chatCmds: { 1: '!normal', 2: '!happy', 3: '!angry', 4: '!sad' },
            
            isTalking: false,
            isShouting: false,
            currentFrameIndex: 0,
            lastFrameTime: 0,
            nextBlinkTime: 0,
            isBlinking: false,
            volume: 0,
            enableSwear: false,
            enableShake: true,
            randomTalk: true,
            isLocked: false,
            
            // Layout
            layout: { 
                avatar: { x: 0, y: 0, scale: 1 }, 
                bg: { x: 0, y: 0, scale: 1 },
                propStatic: { x: 0, y: 0, scale: 1, layer: 'front' }, // Layer added
                propPinned: { x: 0, y: 0, scale: 1 }
            }
        };

        const els = {
            stage: document.getElementById('stage'),
            avatarWrapper: document.getElementById('avatar-wrapper'),
            avatarPhysics: document.getElementById('avatar-physics'),
            avatarImg: document.getElementById('avatar-img'),
            bgWrapper: document.getElementById('bg-wrapper'),
            bgImg: document.getElementById('bg-img'),
            propStaticWrapper: document.getElementById('prop-static-wrapper'),
            propStaticImg: document.getElementById('prop-static-img'),
            propPinnedWrapper: document.getElementById('prop-pinned-wrapper'),
            propPinnedImg: document.getElementById('prop-pinned-img'),
            
            swearLayer: document.getElementById('swear-layer'),
            controls: document.getElementById('controls'),
            volMeter: document.getElementById('vol-meter'),
            
            threshold: document.getElementById('slider-threshold'),
            bounce: document.getElementById('slider-bounce'),
            speedIdle: document.getElementById('slider-speed-idle'),
            speedTalk: document.getElementById('slider-speed-talk'),
            zoom: document.getElementById('slider-zoom'),
            bgColor: document.getElementById('bg-color-picker'),
            randomTalk: document.getElementById('chk-random-talk'),
            audioSelect: document.getElementById('audio-device-select'),
            btnLock: document.getElementById('btn-lock'),
            twitchChannel: document.getElementById('twitch-channel'),
            twitchStatus: document.getElementById('twitch-status'),
            btnLayerStatic: document.getElementById('btn-layer-static')
        };

        // --- CORE FUNCTIONS FOR AUTO-SAVE ---
        
        function getExportData() {
            return {
                modes: state.modes,
                hotkeys: state.hotkeys,
                chatCmds: state.chatCmds,
                settings: {
                    threshold: els.threshold.value,
                    bounce: els.bounce.value,
                    speedIdle: els.speedIdle.value,
                    speedTalk: els.speedTalk.value,
                    zoom: els.zoom.value,
                    enableSwear: state.enableSwear,
                    enableShake: state.enableShake,
                    randomTalk: state.randomTalk,
                    bgColor: els.bgColor.value,
                    twitchChannel: els.twitchChannel.value
                },
                layout: {
                    avatar: { style: els.avatarWrapper.style.cssText, scale: els.avatarWrapper.getAttribute('data-scale') },
                    bg: { style: els.bgWrapper.style.cssText, scale: els.bgWrapper.getAttribute('data-scale'), src: els.bgImg.src },
                    // Save Props
                    propStatic: { style: els.propStaticWrapper.style.cssText, scale: els.propStaticWrapper.getAttribute('data-scale'), src: els.propStaticImg.src, layer: state.layout.propStatic.layer },
                    propPinned: { style: els.propPinnedWrapper.style.cssText, scale: els.propPinnedWrapper.getAttribute('data-scale'), src: els.propPinnedImg.src }
                }
            };
        }

        function applyProfileData(data) {
            if(data.modes) state.modes = data.modes;
            if(data.hotkeys) {
                state.hotkeys = data.hotkeys;
                [1,2,3,4].forEach(id => {
                    document.getElementById(`bind-${id}`).value = state.hotkeys[id].replace('Digit','').replace('Key','');
                    document.getElementById(`badge-${id}`).innerText = document.getElementById(`bind-${id}`).value.substring(0,3);
                });
            }
            if(data.chatCmds) {
                state.chatCmds = data.chatCmds;
                [1,2,3,4].forEach(id => document.getElementById(`cmd-${id}`).value = state.chatCmds[id]);
            }
            if(data.settings) {
                els.threshold.value = data.settings.threshold || 15;
                els.bounce.value = data.settings.bounce || 20;
                els.speedIdle.value = data.settings.speedIdle || 150;
                els.speedTalk.value = data.settings.speedTalk || 60;
                els.zoom.value = data.settings.zoom || 110;
                els.bgColor.value = data.settings.bgColor || '#00b140';
                els.stage.style.backgroundColor = els.bgColor.value;
                els.twitchChannel.value = data.settings.twitchChannel || '';
                
                state.enableSwear = data.settings.enableSwear;
                state.enableShake = data.settings.enableShake;
                state.randomTalk = data.settings.randomTalk;
                
                document.getElementById('btn-toggle-swear').classList.toggle('active', state.enableSwear);
                document.getElementById('btn-toggle-shake').classList.toggle('active', state.enableShake);
                els.randomTalk.checked = state.randomTalk;
            }
            if(data.layout) {
                const applyLayout = (el, cfg, imgEl) => {
                    if(!cfg) return;
                    el.style.cssText = cfg.style;
                    el.setAttribute('data-scale', cfg.scale || 1);
                    if(imgEl && cfg.src && cfg.src.length > 100) {
                        imgEl.src = cfg.src;
                        imgEl.style.display = 'block'; 
                        if(el.style.display === 'none') el.style.display = 'flex';
                    }
                };
                
                applyLayout(els.avatarWrapper, data.layout.avatar);
                applyLayout(els.bgWrapper, data.layout.bg, els.bgImg);
                applyLayout(els.propStaticWrapper, data.layout.propStatic, els.propStaticImg);
                applyLayout(els.propPinnedWrapper, data.layout.propPinned, els.propPinnedImg);
                
                // Restore Layer
                if(data.layout.propStatic && data.layout.propStatic.layer === 'back') {
                    setStaticLayer('back');
                } else {
                    setStaticLayer('front');
                }
            }
            setMode(1);
        }

        // --- AUTO SAVE LOGIC ---
        function saveAuto() {
            try {
                const data = getExportData();
                localStorage.setItem('webTuber_profile', JSON.stringify(data));
            } catch (e) {
                console.warn("Auto-save quota exceeded or error", e);
            }
        }

        function loadAuto() {
            const json = localStorage.getItem('webTuber_profile');
            if (json) {
                try {
                    const data = JSON.parse(json);
                    applyProfileData(data);
                } catch (e) {
                    console.error("Auto-load failed", e);
                }
            }
        }

        window.resetData = () => {
            if(confirm("âš  This will WIPE all your saved images and settings. Are you sure?")) {
                localStorage.removeItem('webTuber_profile');
                location.reload();
            }
        };

        // --- REMOVAL LOGIC ---
        window.clearFrames = (type) => {
            if(confirm(`Clear ${type} frames for this mode?`)) {
                state.modes[state.activeMode][type] = [];
                const label = document.getElementById(`label-${type}`);
                label.innerText = `ðŸ“‚ ${type.charAt(0).toUpperCase() + type.slice(1)} Frames`;
                label.parentElement.classList.remove('border-green-500', 'text-green-400');
                if(type === 'idle') els.avatarImg.src = "";
                saveAuto();
            }
        };

        window.clearProp = (type) => {
            if(confirm(`Remove ${type} prop?`)) {
                const wrapper = document.getElementById(`prop-${type}-wrapper`);
                const img = document.getElementById(`prop-${type}-img`);
                const label = document.getElementById(`label-prop-${type}`);
                
                img.src = "";
                wrapper.style.display = 'none';
                label.innerText = type === 'pinned' ? "ðŸŽ© Pinned" : "ðŸŽ¤ Static";
                
                saveAuto();
            }
        };

        window.clearBg = () => {
            if(confirm("Remove background image?")) {
                els.bgImg.src = "";
                els.bgImg.style.display = 'none';
                document.getElementById('label-bg').innerText = "ðŸ–¼ Upload";
                saveAuto();
            }
        };

        // --- STATIC LAYER LOGIC ---
        function toggleStaticLayer() {
            const current = state.layout.propStatic.layer;
            setStaticLayer(current === 'back' ? 'front' : 'back');
            saveAuto();
        }

        function setStaticLayer(layer) {
            state.layout.propStatic.layer = layer;
            const btn = els.btnLayerStatic;
            if(layer === 'back') {
                els.propStaticWrapper.style.zIndex = 5; // Behind avatar (10)
                btn.innerText = "Back";
                btn.classList.add('back');
            } else {
                els.propStaticWrapper.style.zIndex = 30; // Front
                btn.innerText = "Front";
                btn.classList.remove('back');
            }
        }

        // --- INPUT CONFIGURATION ---
        function setupKeyBinders() {
            [1,2,3,4].forEach(id => {
                const input = document.getElementById(`bind-${id}`);
                input.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    state.hotkeys[id] = e.code; 
                    input.value = e.code.replace('Digit','').replace('Key',''); 
                    document.getElementById(`badge-${id}`).innerText = input.value.substring(0,3); 
                    input.blur();
                    saveAuto(); 
                });
            });
        }
        setupKeyBinders();

        function updateChatCmds() {
            [1,2,3,4].forEach(id => {
                const val = document.getElementById(`cmd-${id}`).value.trim().toLowerCase();
                if(val) state.chatCmds[id] = val;
            });
            saveAuto();
        }
        [1,2,3,4].forEach(id => document.getElementById(`cmd-${id}`).addEventListener('input', updateChatCmds));

        // --- MODE SWITCHING ---
        window.setMode = (modeId) => {
            state.activeMode = modeId;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`mode-${modeId}`).classList.add('active');
            
            const modeName = state.modes[modeId].name;
            document.getElementById('current-mode-name').innerText = modeName;
            
            const idleCount = state.modes[modeId].idle.length;
            const talkCount = state.modes[modeId].talk.length;
            
            const idleLabel = document.getElementById('label-idle');
            const talkLabel = document.getElementById('label-talk');
            
            if(idleCount > 0) {
                idleLabel.innerText = `âœ… ${idleCount} Frames`;
                idleLabel.parentElement.classList.add('border-green-500', 'text-green-400');
            } else {
                idleLabel.innerText = `ðŸ“‚ Idle Frames`;
                idleLabel.parentElement.classList.remove('border-green-500', 'text-green-400');
            }
            
            if(talkCount > 0) {
                talkLabel.innerText = `âœ… ${talkCount} Frames`;
                talkLabel.parentElement.classList.add('border-green-500', 'text-green-400');
            } else {
                talkLabel.innerText = `ðŸ“‚ Talk Frames`;
                talkLabel.parentElement.classList.remove('border-green-500', 'text-green-400');
            }
            
            state.currentFrameIndex = 0;
            state.isBlinking = false;
            
            const activeFrames = state.modes[modeId].idle;
            if(activeFrames.length > 0) els.avatarImg.src = activeFrames[0];
            else els.avatarImg.src = ""; 
        };

        // --- TWITCH INTEGRATION ---
        document.getElementById('btn-twitch-connect').addEventListener('click', () => {
            const channel = els.twitchChannel.value.trim();
            if(!channel) return alert("Enter a channel name!");
            
            try { ComfyJS.Disconnect(); } catch(e){}

            ComfyJS.onCommand = (user, command, message, flags, extra) => {
                const fullCmd = "!" + command.toLowerCase();
                for (const [modeId, trigger] of Object.entries(state.chatCmds)) {
                    if (trigger === fullCmd) {
                        setMode(parseInt(modeId));
                        document.getElementById(`mode-${modeId}`).classList.add('ring-2', 'ring-white');
                        setTimeout(() => document.getElementById(`mode-${modeId}`).classList.remove('ring-2', 'ring-white'), 200);
                    }
                }
            };

            ComfyJS.onConnected = () => {
                els.twitchStatus.innerText = "âœ… Connected to " + channel;
                els.twitchStatus.classList.add('text-green-400');
                saveAuto();
            };

            ComfyJS.Init(channel);
        });

        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;
            for (const [modeId, keyCode] of Object.entries(state.hotkeys)) {
                if (e.code === keyCode) setMode(parseInt(modeId));
            }
            if (e.key.toLowerCase() === 'h') toggleUI();
        });

        // --- EXPORT / IMPORT ---
        window.exportProfile = () => {
            const exportData = getExportData();
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData));
            const node = document.createElement('a');
            node.setAttribute("href", dataStr);
            node.setAttribute("download", "webtuber_profile.json");
            document.body.appendChild(node);
            node.click();
            node.remove();
        };

        document.getElementById('input-load').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;
            const r = new FileReader();
            r.onload = (ev) => {
                try {
                    const data = JSON.parse(ev.target.result);
                    applyProfileData(data);
                    saveAuto();
                    alert("âœ… Profile Loaded!");
                } catch(err) { alert("Error loading profile"); }
            };
            r.readAsText(file);
        });

        // --- INTERACTION ---
        let dragTarget = null;
        let startX, startY, initialLeft, initialTop;

        function makeInteractive(el) {
            el.addEventListener('mousedown', (e) => {
                if (state.isLocked) return;
                if (e.button !== 0) return;
                e.stopPropagation(); // FIX for pinned props
                e.preventDefault();
                dragTarget = el;
                startX = e.clientX;
                startY = e.clientY;
                initialLeft = el.offsetLeft;
                initialTop = el.offsetTop;
            });

            el.addEventListener('wheel', (e) => {
                if (state.isLocked) return;
                e.preventDefault();
                let currentScale = parseFloat(el.getAttribute('data-scale')) || 1;
                const delta = e.deltaY > 0 ? -0.05 : 0.05;
                let newScale = Math.max(0.1, currentScale + delta);
                el.setAttribute('data-scale', newScale);
                updateTransform(el);
                saveAuto();
            });
        }

        window.addEventListener('mousemove', (e) => {
            if (!dragTarget || state.isLocked) return;
            e.preventDefault();
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            dragTarget.style.left = `${initialLeft + dx}px`;
            dragTarget.style.top = `${initialTop + dy}px`;
            dragTarget.setAttribute('data-dragged', 'true');
            updateTransform(dragTarget);
        });

        window.addEventListener('mouseup', () => { 
            if(dragTarget) {
                dragTarget = null;
                saveAuto(); 
            }
        });

        function updateTransform(el) {
            const scale = parseFloat(el.getAttribute('data-scale')) || 1;
            const isDragged = el.getAttribute('data-dragged') === 'true';
            el.style.transform = isDragged ? `scale(${scale})` : `translate(-50%, -50%) scale(${scale})`;
        }

        makeInteractive(els.avatarWrapper);
        makeInteractive(els.bgWrapper);
        makeInteractive(els.propStaticWrapper);
        makeInteractive(els.propPinnedWrapper);

        els.btnLock.addEventListener('click', () => {
            state.isLocked = !state.isLocked;
            if (state.isLocked) {
                els.btnLock.innerHTML = "<span>ðŸ”’</span> Locked";
                els.btnLock.classList.add('bg-red-900', 'border-red-700', 'text-red-200');
                document.querySelectorAll('.interactive-layer').forEach(el => el.classList.add('locked'));
            } else {
                els.btnLock.innerHTML = "<span>ðŸ”“</span> Unlocked";
                els.btnLock.className = "toggle-btn w-full flex justify-center items-center gap-2";
                document.querySelectorAll('.interactive-layer').forEach(el => el.classList.remove('locked'));
            }
        });

        window.resetLayout = () => {
            if(confirm("Reset positions?")) {
                ['avatarWrapper', 'bgWrapper', 'propStaticWrapper', 'propPinnedWrapper'].forEach(key => {
                    const el = els[key];
                    el.style.left = '50%';
                    el.style.top = '50%';
                    el.setAttribute('data-scale', 1);
                    el.setAttribute('data-dragged', 'false');
                    el.style.transform = `translate(-50%, -50%) scale(1)`;
                });
                saveAuto();
            }
        };

        // --- AUDIO ENGINE ---
        async function getAudioDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                els.audioSelect.innerHTML = '<option value="">Default Microphone</option>';
                audioInputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Microphone ${els.audioSelect.length + 1}`;
                    els.audioSelect.appendChild(option);
                });
                const savedDevice = localStorage.getItem('webTuber_audioDevice');
                if (savedDevice) els.audioSelect.value = savedDevice;
            } catch(e) { console.error("Device Enum Error", e); }
        }
        getAudioDevices();

        els.audioSelect.addEventListener('change', () => {
            localStorage.setItem('webTuber_audioDevice', els.audioSelect.value);
        });

        async function startMicrophone() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (state.audioContext) state.audioContext.close();
                state.audioContext = new AudioContext();
                const constraints = { audio: true };
                if(els.audioSelect.value) constraints.audio = { deviceId: { exact: els.audioSelect.value } };

                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                const microphone = state.audioContext.createMediaStreamSource(stream);
                state.analyser = state.audioContext.createAnalyser();
                state.analyser.fftSize = 512;
                microphone.connect(state.analyser);
                state.dataArray = new Uint8Array(state.analyser.frequencyBinCount);
                
                document.getElementById('btn-start').innerHTML = "<span>âœ…</span> Mic Active";
                document.getElementById('btn-start').classList.replace('bg-purple-600', 'bg-green-700');
                localStorage.setItem('webTuber_micPermission', 'true');
                await getAudioDevices();
                if (!state.isAnimating) {
                    state.isAnimating = true;
                    initSwearParticles();
                    animate();
                }
            } catch (err) { 
                if (err.name === 'NotAllowedError') {
                    alert("Microphone denied. Please check browser permissions.");
                    localStorage.removeItem('webTuber_micPermission');
                }
            }
        }

        document.getElementById('btn-start').addEventListener('click', startMicrophone);
        window.addEventListener('load', async () => {
            loadAuto();
            if (localStorage.getItem('webTuber_micPermission') === 'true') startMicrophone();
        });

        function animate() {
            requestAnimationFrame(animate);
            if (state.analyser) {
                state.analyser.getByteFrequencyData(state.dataArray);
                let sum = 0;
                for(let i = 0; i < state.dataArray.length; i++) sum += state.dataArray[i];
                const average = sum / state.dataArray.length;
                state.volume = state.volume * 0.8 + average * 0.2;
                els.volMeter.innerText = Math.floor(state.volume);
            }

            const threshold = parseInt(els.threshold.value);
            const wasTalking = state.isTalking;
            state.isTalking = state.volume > threshold;
            state.isShouting = state.volume > (threshold * 2.5) || state.volume > 80;

            if (wasTalking !== state.isTalking) {
                state.currentFrameIndex = 0;
                state.lastFrameTime = 0;
                state.isBlinking = false;
            }

            const now = Date.now();
            const activeModeObj = state.modes[state.activeMode];
            
            if (state.isTalking) {
                const speed = parseInt(els.speedTalk.value);
                if (now - state.lastFrameTime > speed) {
                    if (state.randomTalk && activeModeObj.talk.length > 1) {
                        let nextFrame;
                        do {
                            nextFrame = Math.floor(Math.random() * activeModeObj.talk.length);
                        } while (nextFrame === state.currentFrameIndex && activeModeObj.talk.length > 1);
                        state.currentFrameIndex = nextFrame;
                    } else {
                        state.currentFrameIndex = (state.currentFrameIndex + 1) % activeModeObj.talk.length;
                    }
                    if(activeModeObj.talk.length > 0) els.avatarImg.src = activeModeObj.talk[state.currentFrameIndex];
                    state.lastFrameTime = now;
                }
            } else {
                const speed = parseInt(els.speedIdle.value);
                if (!state.isBlinking && now > state.nextBlinkTime) {
                    state.isBlinking = true;
                    state.currentFrameIndex = 0; 
                }
                if (state.isBlinking && activeModeObj.idle.length > 1) {
                    if (now - state.lastFrameTime > speed) {
                        state.currentFrameIndex++;
                        if (state.currentFrameIndex >= activeModeObj.idle.length) {
                            state.currentFrameIndex = 0;
                            state.isBlinking = false;
                            state.nextBlinkTime = now + (Math.random() * 3000 + 2000);
                        }
                        els.avatarImg.src = activeModeObj.idle[state.currentFrameIndex];
                        state.lastFrameTime = now;
                    }
                } else if(activeModeObj.idle.length > 0 && els.avatarImg.src !== activeModeObj.idle[0]) {
                    els.avatarImg.src = activeModeObj.idle[0];
                }
            }

            let scaleX = 1, scaleY = 1, translateY = 0, rotate = 0;
            const bounceFactor = parseInt(els.bounce.value) / 3000;
            if (state.volume > 5) {
                const intensity = Math.max(0, state.volume - threshold); 
                const deformation = intensity * bounceFactor; 
                scaleY = 1 - (deformation * 0.2); 
                scaleX = 1 + (deformation * 0.1); 
                translateY = deformation * 10;
            }

            let zoomScale = 1;
            if (state.isShouting) {
                zoomScale = parseInt(els.zoom.value) / 100;
                if (state.enableShake) {
                    rotate = (Math.random() - 0.5) * 5;
                    translateY += (Math.random() - 0.5) * 10;
                }
                if (state.enableSwear) {
                    els.swearLayer.style.opacity = 1;
                    Array.from(els.swearLayer.children).forEach(c => {
                        c.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px) rotate(${Math.random()*20-10}deg)`;
                    });
                } else els.swearLayer.style.opacity = 0;
            } else els.swearLayer.style.opacity = 0;

            els.stage.style.transform = `scale(${state.isShouting ? zoomScale : 1})`;
            els.avatarPhysics.style.transform = `translate(0px, ${translateY}px) scale(${scaleX}, ${scaleY}) rotate(${rotate}deg)`;
            els.avatarImg.style.filter = (state.isShouting && state.volume > 90) ? "brightness(1.2)" : "brightness(1.0)";
        }

        // --- FILE HANDLING ---
        function handleUpload(inputId, labelId, type) {
            document.getElementById(inputId).addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                    const loadedFrames = [];
                    let count = 0;
                    files.forEach((file, i) => {
                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            loadedFrames[i] = ev.target.result;
                            count++;
                            if (count === files.length) {
                                state.modes[state.activeMode][type] = loadedFrames;
                                state.currentFrameIndex = 0;
                                document.getElementById(labelId).innerText = `âœ… ${files.length} Frames`;
                                document.getElementById(labelId).parentElement.classList.add('border-green-500', 'text-green-400');
                                if(type === 'idle') els.avatarImg.src = loadedFrames[0];
                                saveAuto();
                            }
                        };
                        reader.readAsDataURL(file);
                    });
                }
            });
        }

        handleUpload('input-idle', 'label-idle', 'idle');
        handleUpload('input-talk', 'label-talk', 'talk');

        // Props Upload Handlers
        const handlePropUpload = (inputId, labelId, wrapperId, imgId, stateKey) => {
            document.getElementById(inputId).addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        document.getElementById(imgId).src = ev.target.result;
                        document.getElementById(wrapperId).style.display = 'flex';
                        document.getElementById(labelId).innerText = "âœ… Loaded";
                        saveAuto();
                    };
                    reader.readAsDataURL(file);
                }
            });
        };

        handlePropUpload('input-prop-static', 'label-prop-static', 'prop-static-wrapper', 'prop-static-img', 'propStatic');
        handlePropUpload('input-prop-pinned', 'label-prop-pinned', 'prop-pinned-wrapper', 'prop-pinned-img', 'propPinned');

        document.getElementById('input-bg').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    els.bgImg.src = ev.target.result;
                    els.bgImg.style.display = 'block';
                    document.getElementById('label-bg').innerText = "âœ… Loaded";
                    saveAuto(); 
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('bg-color-picker').addEventListener('input', (e) => {
            els.stage.style.backgroundColor = e.target.value;
            saveAuto();
        });

        function initSwearParticles() {
            const symbols = ['@', '#', '!', '%', '&', '$', 'ðŸ¤¬', 'ðŸ’¢'];
            for(let i=0; i<10; i++) {
                const el = document.createElement('div');
                el.className = 'swear-symbol';
                el.innerText = symbols[Math.floor(Math.random() * symbols.length)];
                el.style.left = (20 + Math.random() * 60) + '%';
                el.style.top = (10 + Math.random() * 40) + '%';
                el.style.fontSize = (20 + Math.random() * 30) + 'px';
                el.style.transform = `rotate(${Math.random() * 60 - 30}deg)`;
                els.swearLayer.appendChild(el);
            }
        }

        const toggleUI = () => {
            els.controls.classList.toggle('hidden');
            document.body.classList.toggle('show-hint');
        };
        document.getElementById('btn-hide').addEventListener('click', toggleUI);
        window.addEventListener('keydown', (e) => { if (e.key.toLowerCase() === 'h') toggleUI(); });

        ['btn-toggle-swear', 'btn-toggle-shake'].forEach(id => {
            document.getElementById(id).addEventListener('click', function() {
                this.classList.toggle('active');
                if(id.includes('swear')) state.enableSwear = !state.enableSwear;
                if(id.includes('shake')) state.enableShake = !state.enableShake;
                saveAuto(); 
            });
        });

        els.randomTalk.addEventListener('change', (e) => {
            state.randomTalk = e.target.checked;
            saveAuto();
        });
        
        [els.threshold, els.bounce, els.speedIdle, els.speedTalk, els.zoom].forEach(el => {
            el.addEventListener('change', saveAuto);
        });
        
        els.speedIdle.addEventListener('input', (e) => document.getElementById('speed-idle-val').innerText = e.target.value + 'ms');
        els.speedTalk.addEventListener('input', (e) => document.getElementById('speed-talk-val').innerText = e.target.value + 'ms');

    </script>
</body>
</html>
