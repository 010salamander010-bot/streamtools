<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Streamagochi</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* CRITICAL: OBS Transparency */
        html, body { 
            background-color: transparent !important; 
            background: transparent !important;
            margin: 0; 
            padding: 0; 
            width: 100vw; 
            height: 100vh; 
            overflow: hidden; 
            font-family: 'Segoe UI', sans-serif;
        }
        
        #root {
            background-color: transparent !important;
            width: 100%;
            height: 100%;
        }

        /* Container for the sliding pet */
        .sliding-container {
            position: fixed;
            z-index: 999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: transparent !important;
            /* Transition is applied dynamically to allow 'teleporting' while hidden */
        }
        
        @keyframes breathe { 0%, 100% { transform: scale(1); border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; } 50% { transform: scale(1.05); border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; } }
        @keyframes jump { 0%, 100% { transform: translateY(0) scale(1); } 50% { transform: translateY(-20px) scale(0.9); } }
        @keyframes shake { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(-10deg); } 75% { transform: rotate(10deg); } }
        @keyframes sleep { 0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.8; } 50% { transform: scale(0.95) rotate(1deg); opacity: 0.6; } }

        .blob { 
            width: 100px; 
            height: 100px; 
            background: var(--pet-color, #ff6b6b); 
            border: 4px solid rgba(0,0,0,0.2); 
            position: relative; 
            transition: all 0.5s ease; 
            box-shadow: inset -8px -8px 16px rgba(0,0,0,0.15); 
        }
        .blob-face { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 60%; display: flex; justify-content: space-between; align-items: center; }
        .eye { width: 10px; height: 10px; background: #333; border-radius: 50%; animation: blink 4s infinite; }
        .mouth { width: 14px; height: 7px; border-bottom: 3px solid #333; border-radius: 50%; }
        @keyframes blink { 0%, 96%, 100% { transform: scaleY(1); } 98% { transform: scaleY(0.1); } }
        
        .status-bar-bg { background: rgba(0,0,0,0.5); height: 6px; border-radius: 3px; overflow: hidden; width: 100%; }
        .status-fill { height: 100%; transition: width 0.5s, background-color 0.5s; }

        .anim-idle { animation: breathe 4s infinite ease-in-out; }
        .anim-eat { animation: shake 0.5s infinite; }
        .anim-happy { animation: jump 0.5s infinite; }
        .anim-sleep { animation: sleep 3s infinite ease-in-out; }

        .bubble {
            position: absolute;
            top: -45px;
            background: white;
            padding: 4px 10px;
            border-radius: 15px;
            color: black;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            font-size: 1.2rem;
            animation: jump 1.5s infinite;
            z-index: 10;
        }
        .bubble::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid white;
        }
    </style>
</head>
<body class="text-white">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const StatusBar = ({ icon, value, color }) => (
            <div className="flex items-center space-x-2 w-full mb-1">
                <span className="text-xs">{icon}</span>
                <div className="flex-1 flex flex-col">
                    <div className="status-bar-bg">
                        <div className="status-fill" style={{ width: `${value}%`, backgroundColor: value < 30 ? '#ef4444' : color }}></div>
                    </div>
                </div>
            </div>
        );

        const PetBlob = ({ status, color, stats, threshold }) => {
            let animClass = "anim-idle";
            let mouthStyle = {};
            let eyeStyle = {};
            let emoji = null;

            if (status === 'dead') emoji = "üíÄ";
            else if (status === 'eating') emoji = "üçî";
            else if (status === 'playing') emoji = "üéæ";
            else if (stats.hunger < threshold) emoji = "üçî?";
            else if (stats.fun < threshold) emoji = "üéæ?";
            else if (stats.energy < threshold) emoji = "‚ö°";

            if (status === 'eating') {
                animClass = "anim-eat";
                mouthStyle = { height: '12px', borderRadius: '50%', background: '#333' };
            } else if (status === 'playing') {
                animClass = "anim-happy";
                mouthStyle = { borderBottom: '3px solid #333', transform: 'scale(1.2)' };
            } else if (status === 'sleeping') {
                animClass = "anim-sleep";
                eyeStyle = { height: '2px', borderRadius: '0', transform: 'scaleY(1)' };
                mouthStyle = { width: '8px', height: '8px', borderRadius: '50%', border: '2px solid #333' };
            } else if (status === 'dead') {
                animClass = "";
                eyeStyle = { transform: 'rotate(45deg)', borderRadius: '0', height: '2px', width: '12px' };
            }

            return (
                <div className={`blob ${animClass}`} style={{ '--pet-color': color }}>
                    {emoji && <div className="bubble">{emoji}</div>}
                    <div className="blob-face">
                        <div className="eye" style={eyeStyle}></div>
                        <div className="mouth" style={mouthStyle}></div>
                        <div className="eye" style={eyeStyle}></div>
                    </div>
                    {status === 'sleeping' && <div className="absolute -top-12 left-0 text-xl font-bold text-white animate-pulse">Zzz...</div>}
                </div>
            );
        };

        function App() {
            const getParam = (key) => new URLSearchParams(window.location.search).get(key);
            const channel = getParam('channel') || localStorage.getItem('pet_channel') || '';
            const mode = getParam('mode') || 'fixed'; 
            const isTest = getParam('test') === 'true';

            // --- CONFIGURATION ---
            const PEEK_MIN_MS = isTest ? 5000 : 30 * 60 * 1000;
            const PEEK_MAX_MS = isTest ? 10000 : 60 * 60 * 1000;
            const PEEK_DURATION_MS = 7000;
            const DECAY_RATE_MS = 5000; 
            const CRITICAL_THRESHOLD = 30;
            const CMD_BOOST = 6; // Slower progress filling
            const DECAY_AMT = 0.04; // Much slower decay

            const [stats, setStats] = useState(() => {
                const saved = localStorage.getItem('pet_stats');
                return saved ? JSON.parse(saved) : { hunger: 80, fun: 80, energy: 80 };
            });
            const [petStatus, setPetStatus] = useState('idle');
            const [feedback, setFeedback] = useState(null);
            
            const [isVisuallyActive, setIsVisuallyActive] = useState(mode === 'fixed');
            const [peekConfig, setPeekConfig] = useState({ edge: 'bottom', offset: 50 });
            const [transitionEnabled, setTransitionEnabled] = useState(true);

            const activeRef = useRef(mode === 'fixed');
            const hideTimeoutRef = useRef(null);
            const scheduledTimeoutRef = useRef(null);

            useEffect(() => {
                activeRef.current = isVisuallyActive;
            }, [isVisuallyActive]);

            const randomizePeek = useCallback(() => {
                const edges = ['top', 'bottom', 'left', 'right'];
                const edge = edges[Math.floor(Math.random() * edges.length)];
                const offset = Math.floor(Math.random() * 60) + 20; 
                setPeekConfig({ edge, offset });
            }, []);

            const triggerPeek = useCallback(() => {
                if (activeRef.current && mode === 'peek') return; 
                
                // 1. Disable transitions to teleport instantly while invisible
                setTransitionEnabled(false);
                randomizePeek();
                
                // 2. Wait for DOM to register position, then enable transition and slide in
                setTimeout(() => {
                    setTransitionEnabled(true);
                    setIsVisuallyActive(true);
                    
                    if (hideTimeoutRef.current) clearTimeout(hideTimeoutRef.current);
                    hideTimeoutRef.current = setTimeout(() => {
                        if (mode === 'peek') setIsVisuallyActive(false);
                    }, PEEK_DURATION_MS);
                }, 100);
            }, [mode, randomizePeek, PEEK_DURATION_MS]);

            // --- SCHEDULED PEEKS ---
            useEffect(() => {
                if (!channel || mode !== 'peek') return;

                const scheduleNext = () => {
                    const delay = Math.floor(Math.random() * (PEEK_MAX_MS - PEEK_MIN_MS) + PEEK_MIN_MS);
                    scheduledTimeoutRef.current = setTimeout(() => {
                        triggerPeek();
                        scheduleNext();
                    }, delay);
                };

                scheduleNext();
                return () => clearTimeout(scheduledTimeoutRef.current);
            }, [channel, mode, triggerPeek, PEEK_MIN_MS, PEEK_MAX_MS]);

            // --- CRITICAL AUTO-PEEK ---
            useEffect(() => {
                if (mode !== 'peek') return;
                const isCritical = stats.hunger < CRITICAL_THRESHOLD || stats.fun < CRITICAL_THRESHOLD || stats.energy < CRITICAL_THRESHOLD || petStatus === 'dead';
                if (isCritical && !isVisuallyActive) triggerPeek();
            }, [stats, petStatus, mode, isVisuallyActive, triggerPeek]);

            const getSlidingStyles = () => {
                if (mode === 'fixed') return { 
                    bottom: '20px', 
                    left: '50%', 
                    transform: 'translateX(-50%)', 
                    opacity: 1,
                    transition: 'all 1.2s cubic-bezier(0.22, 1, 0.36, 1)'
                };

                // Logic: Blob is 100px. Hide 30%, show 70% (70px).
                // Onscreen buffer should be -30px relative to the edge.
                const offscreenBuffer = '-180px';
                const onscreenBuffer = '-30px'; 
                
                const { edge, offset } = peekConfig;
                let styles = { 
                    opacity: isVisuallyActive ? 1 : 0,
                    transition: transitionEnabled ? 'all 1.2s cubic-bezier(0.22, 1, 0.36, 1)' : 'none'
                };

                if (edge === 'bottom') {
                    styles.bottom = isVisuallyActive ? onscreenBuffer : offscreenBuffer;
                    styles.left = `${offset}%`;
                    styles.transform = 'translateX(-50%)';
                } else if (edge === 'top') {
                    styles.top = isVisuallyActive ? onscreenBuffer : offscreenBuffer;
                    styles.left = `${offset}%`;
                    styles.transform = 'translateX(-50%)';
                } else if (edge === 'left') {
                    styles.left = isVisuallyActive ? onscreenBuffer : offscreenBuffer;
                    styles.top = `${offset}%`;
                    styles.transform = 'translateY(-50%)';
                } else if (edge === 'right') {
                    styles.right = isVisuallyActive ? onscreenBuffer : offscreenBuffer;
                    styles.top = `${offset}%`;
                    styles.transform = 'translateY(-50%)';
                }
                return styles;
            };

            // --- GAME LOOP ---
            useEffect(() => {
                const decay = setInterval(() => {
                    setStats(curr => {
                        let { hunger, fun, energy } = curr;
                        if (petStatus === 'sleeping') {
                            energy = Math.min(100, energy + 2);
                            hunger = Math.max(0, hunger - (DECAY_AMT / 2));
                            if (energy >= 100) setPetStatus('idle');
                        } else {
                            hunger = Math.max(0, hunger - DECAY_AMT);
                            fun = Math.max(0, fun - DECAY_AMT);
                            energy = Math.max(0, energy - (DECAY_AMT / 2));
                        }
                        if (hunger <= 0) setPetStatus('dead');
                        return { ...curr, hunger, fun, energy };
                    });
                }, DECAY_RATE_MS);
                return () => clearInterval(decay);
            }, [petStatus, DECAY_AMT]);

            const feed = () => {
                if (petStatus === 'dead' || petStatus === 'sleeping') return;
                setStats(s => ({ ...s, hunger: Math.min(100, s.hunger + CMD_BOOST) }));
                setPetStatus('eating');
                setFeedback("üçî YUM!");
                triggerPeek();
                setTimeout(() => { setPetStatus('idle'); setFeedback(null); }, 3000);
            };

            const play = () => {
                if (petStatus === 'dead' || petStatus === 'sleeping') return;
                setStats(s => ({ ...s, fun: Math.min(100, s.fun + CMD_BOOST), energy: Math.max(0, s.energy - (CMD_BOOST / 2)) }));
                setPetStatus('playing');
                setFeedback("üéæ YAY!");
                triggerPeek();
                setTimeout(() => { setPetStatus('idle'); setFeedback(null); }, 3000);
            };

            const sleep = () => {
                if (petStatus === 'dead') return;
                setPetStatus('sleeping');
                setFeedback("üí§ ZZZ...");
                triggerPeek();
                setTimeout(() => setFeedback(null), 3000);
            };

            const revive = () => {
                 setStats({ hunger: 70, fun: 70, energy: 70 });
                 setPetStatus('idle');
                 setFeedback("‚ú® ALIVE!");
                 triggerPeek();
                 setTimeout(() => setFeedback(null), 3000);
            };

            useEffect(() => {
                if (!channel) return;
                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
                socket.onopen = () => {
                    socket.send('CAP REQ :twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan123');
                    socket.send(`JOIN #${channel.toLowerCase()}`);
                };
                socket.onmessage = (e) => {
                    const msg = e.data;
                    if (msg.startsWith('PING')) socket.send('PONG :tmi.twitch.tv');
                    const parts = msg.split('PRIVMSG');
                    if (!parts[1]) return;
                    const text = parts[1].split(':').slice(1).join(':').trim().toLowerCase();
                    if (!text) return;
                    if (text.startsWith('!feed')) feed();
                    if (text.startsWith('!play') || text.startsWith('!pet')) play();
                    if (text.startsWith('!sleep')) sleep();
                    if (text.startsWith('!revive')) revive();
                };
                return () => socket.close();
            }, [channel, petStatus]);

            // --- UI RENDER ---
            if (!channel) {
                return (
                    <div className="flex items-center justify-center h-full bg-transparent">
                        <div className="bg-gray-800 p-8 rounded-2xl shadow-2xl w-96 border border-purple-500/30">
                            <h1 className="text-3xl font-bold mb-2 text-purple-400">Streamagochi</h1>
                            <p className="text-gray-400 mb-6 text-sm">Twitch Overlay Setup</p>
                            <input className="w-full bg-gray-900 border border-gray-700 p-3 rounded-lg mb-4 text-white outline-none focus:border-purple-500" placeholder="Twitch Channel" id="c" />
                            <div className="grid grid-cols-2 gap-2">
                                <button onClick={() => window.location.search = `?channel=${document.getElementById('c').value}&mode=peek&test=true`} className="bg-purple-600 p-3 rounded-lg font-bold hover:bg-purple-500">Start Test Mode</button>
                                <button onClick={() => window.location.search = `?channel=${document.getElementById('c').value}&mode=peek`} className="bg-gray-700 p-3 rounded-lg font-bold hover:bg-gray-600">Start Real Mode</button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="w-full h-full relative bg-transparent">
                    <div className="sliding-container" style={getSlidingStyles()}>
                        {mode === 'fixed' && (
                            <div className="bg-black/80 p-3 rounded-xl w-36 mb-4 border border-white/10 shadow-xl">
                                <StatusBar icon="üçó" value={stats.hunger} color="#10b981" />
                                <StatusBar icon="üòä" value={stats.fun} color="#3b82f6" />
                                <StatusBar icon="‚ö°" value={stats.energy} color="#f59e0b" />
                            </div>
                        )}
                        {feedback && (
                            <div className="absolute -top-16 text-xl font-black text-white drop-shadow-[0_4px_4px_rgba(0,0,0,0.8)] animate-bounce text-center w-48">
                                {feedback}
                            </div>
                        )}
                        <PetBlob 
                            status={petStatus} 
                            color="#a78bfa" 
                            stats={stats} 
                            threshold={CRITICAL_THRESHOLD} 
                        />
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
