<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Streamagochi</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { font-family: 'Segoe UI', sans-serif; overflow: hidden; margin: 0; padding: 0; width: 100vw; height: 100vh; }
        
        .obs-transparent { 
            background-color: transparent !important; 
            background: transparent !important;
        }

        .fade-container {
            transition: opacity 1s ease-in-out, top 0.5s ease-out, left 0.5s ease-out;
            position: absolute;
        }
        
        @keyframes breathe { 0%, 100% { transform: scale(1); border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; } 50% { transform: scale(1.05); border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; } }
        @keyframes jump { 0%, 100% { transform: translateY(0) scale(1); } 50% { transform: translateY(-20px) scale(0.9); } }
        @keyframes shake { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(-10deg); } 75% { transform: rotate(10deg); } }
        @keyframes sleep { 0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.8; } 50% { transform: scale(0.95) rotate(1deg); opacity: 0.6; } }

        .blob { width: 120px; height: 120px; background: var(--pet-color, #ff6b6b); border: 4px solid rgba(0,0,0,0.2); position: relative; transition: all 0.5s ease; box-shadow: inset -10px -10px 20px rgba(0,0,0,0.1); }
        .blob-face { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 60%; display: flex; justify-content: space-between; align-items: center; }
        .eye { width: 12px; height: 12px; background: #333; border-radius: 50%; animation: blink 4s infinite; }
        .mouth { width: 16px; height: 8px; border-bottom: 3px solid #333; border-radius: 50%; }
        @keyframes blink { 0%, 96%, 100% { transform: scaleY(1); } 98% { transform: scaleY(0.1); } }
        
        .status-bar-bg { background: rgba(0,0,0,0.5); height: 6px; border-radius: 3px; overflow: hidden; width: 100%; }
        .status-fill { height: 100%; transition: width 0.5s, background-color 0.5s; }

        .anim-idle { animation: breathe 4s infinite ease-in-out; }
        .anim-eat { animation: shake 0.5s infinite; }
        .anim-happy { animation: jump 0.5s infinite; }
        .anim-sleep { animation: sleep 3s infinite ease-in-out; }

        /* Distress Bubble */
        .bubble {
            position: absolute;
            top: -40px;
            right: -20px;
            background: white;
            padding: 4px 8px;
            border-radius: 20px;
            color: black;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-size: 1.2rem;
            animation: jump 1s infinite;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="root" class="w-full h-full relative"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- CONFIGURATION ---
        // Adjusted for testing (Shortened from 30m to 1m)
        const PEEK_MIN_MS = 60 * 1000; 
        const PEEK_MAX_MS = 120 * 1000; 
        const PEEK_DURATION_MS = 10000; // Visible for 10 seconds
        const DECAY_RATE_MS = 5000; 
        const SAVE_INTERVAL_MS = 10000;
        const CRITICAL_THRESHOLD = 30; // Show warning emoji if stat < 30
        
        const DEFAULT_CONFIG = {
            petName: 'Glitch',
            color: '#a78bfa',
            maxStat: 100
        };

        const StatusBar = ({ icon, value, color }) => (
            <div className="flex items-center space-x-2 w-full mb-1">
                <span className="text-sm">{icon}</span>
                <div className="flex-1 flex flex-col">
                    <div className="status-bar-bg">
                        <div className="status-fill" style={{ width: `${value}%`, backgroundColor: value < 30 ? '#ef4444' : color }}></div>
                    </div>
                </div>
            </div>
        );

        const PetBlob = ({ status, color, isCritical }) => {
            let animClass = "anim-idle";
            let mouthStyle = {};
            let eyeStyle = {};
            let distressEmoji = null;

            if (isCritical) distressEmoji = "‚ùó";
            if (status === 'dead') distressEmoji = "üíÄ";

            if (status === 'eating') {
                animClass = "anim-eat";
                mouthStyle = { height: '15px', borderRadius: '50%', background: '#333' };
            } else if (status === 'playing') {
                animClass = "anim-happy";
                mouthStyle = { borderBottom: '3px solid #333', transform: 'scale(1.2)' };
            } else if (status === 'sleeping') {
                animClass = "anim-sleep";
                eyeStyle = { height: '2px', borderRadius: '0', transform: 'scaleY(1)' };
                mouthStyle = { width: '8px', height: '8px', borderRadius: '50%', border: '2px solid #333' };
            } else if (status === 'dead') {
                animClass = "";
                eyeStyle = { transform: 'rotate(45deg)', borderRadius: '0', height: '2px', width: '12px' };
            }

            return (
                <div className={`blob ${animClass}`} style={{ '--pet-color': color }}>
                    {distressEmoji && <div className="bubble">{distressEmoji}</div>}
                    <div className="blob-face">
                        <div className="eye" style={eyeStyle}></div>
                        <div className="mouth" style={mouthStyle}></div>
                        <div className="eye" style={eyeStyle}></div>
                    </div>
                    {status === 'sleeping' && <div className="absolute -top-10 left-0 text-xl font-bold text-white animate-pulse">Zzz...</div>}
                </div>
            );
        };

        function App() {
            const getParam = (key) => new URLSearchParams(window.location.search).get(key);
            const channel = getParam('channel') || localStorage.getItem('pet_channel') || '';
            const mode = getParam('mode') || 'fixed'; 

            const [stats, setStats] = useState(() => {
                const saved = localStorage.getItem('pet_stats');
                return saved ? JSON.parse(saved) : { hunger: 80, fun: 80, energy: 80 };
            });
            const [petStatus, setPetStatus] = useState('idle');
            const [feedback, setFeedback] = useState(null);
            
            // Visibility & Positioning
            const [isPeeking, setIsPeeking] = useState(false);
            const [forceVisible, setForceVisible] = useState(false);
            const [pos, setPos] = useState({ x: 50, y: 90 }); // Default: Bottom Center
            const [nextPeekTime, setNextPeekTime] = useState(null);
            const [timeRemaining, setTimeRemaining] = useState('');

            const ws = useRef(null);
            const peekTimeoutRef = useRef(null);
            const hideTimeoutRef = useRef(null);

            // --- POSITIONING HELPER ---
            const randomizePosition = useCallback(() => {
                const x = Math.floor(Math.random() * 80) + 10; // 10% to 90%
                const y = Math.floor(Math.random() * 70) + 20; // 20% to 90%
                setPos({ x, y });
            }, []);

            // --- PEEK LOGIC ---
            useEffect(() => {
                if (!channel || mode !== 'peek') return;

                const scheduleNextPeek = () => {
                    const delay = Math.floor(Math.random() * (PEEK_MAX_MS - PEEK_MIN_MS) + PEEK_MIN_MS);
                    setNextPeekTime(Date.now() + delay);
                    
                    peekTimeoutRef.current = setTimeout(() => {
                        randomizePosition();
                        setIsPeeking(true);
                        hideTimeoutRef.current = setTimeout(() => {
                            setIsPeeking(false);
                            scheduleNextPeek();
                        }, PEEK_DURATION_MS);
                    }, delay);
                };

                scheduleNextPeek();

                return () => {
                    clearTimeout(peekTimeoutRef.current);
                    clearTimeout(hideTimeoutRef.current);
                };
            }, [channel, mode, randomizePosition]);

            // --- COUNTDOWN ---
            useEffect(() => {
                if (mode !== 'peek' || !nextPeekTime) return;
                const interval = setInterval(() => {
                    const diff = nextPeekTime - Date.now();
                    if (diff <= 0) setTimeRemaining("Soon...");
                    else {
                        const mins = Math.floor(diff / 60000);
                        const secs = Math.floor((diff % 60000) / 1000);
                        setTimeRemaining(`${mins}m ${secs}s`);
                    }
                }, 1000);
                return () => clearInterval(interval);
            }, [nextPeekTime, mode]);

            // --- CRITICAL CHECK ---
            const isCritical = stats.hunger < CRITICAL_THRESHOLD || stats.fun < CRITICAL_THRESHOLD || stats.energy < CRITICAL_THRESHOLD;

            useEffect(() => {
                if (mode === 'fixed') {
                    setForceVisible(true);
                    setPos({ x: 50, y: 90 });
                    return;
                }

                const isInteracting = petStatus === 'eating' || petStatus === 'playing';
                const isDead = petStatus === 'dead';

                if (isCritical || isInteracting || isDead) {
                    // If we weren't already visible, pick a spot
                    if (!forceVisible && !isPeeking) randomizePosition();
                    setForceVisible(true);
                } else {
                    setForceVisible(false);
                }
            }, [stats, petStatus, mode, isCritical, isPeeking, forceVisible, randomizePosition]);

            // --- UI HANDLING ---
            useEffect(() => {
                if (channel) {
                    document.body.classList.add('obs-transparent');
                    document.body.classList.remove('bg-gray-900');
                } else {
                    document.body.classList.remove('obs-transparent');
                    document.body.classList.add('bg-gray-900');
                }
            }, [channel]);

            // --- GAME LOOP ---
            useEffect(() => {
                const interval = setInterval(() => {
                    localStorage.setItem('pet_stats', JSON.stringify(stats));
                }, SAVE_INTERVAL_MS);
                
                if (petStatus === 'dead') return () => clearInterval(interval);

                const decay = setInterval(() => {
                    setStats(curr => {
                        let { hunger, fun, energy } = curr;
                        if (petStatus === 'sleeping') {
                            energy = Math.min(100, energy + 5);
                            hunger = Math.max(0, hunger - 1.5);
                            if (energy >= 100) setPetStatus('idle');
                        } else {
                            hunger = Math.max(0, hunger - 0.8);
                            fun = Math.max(0, fun - 0.8);
                            energy = Math.max(0, energy - 0.4);
                        }
                        if (hunger <= 0) setPetStatus('dead');
                        return { hunger, fun, energy };
                    });
                }, DECAY_RATE_MS);

                return () => { clearInterval(interval); clearInterval(decay); };
            }, [petStatus]);

            // --- ACTIONS ---
            const showFloatingText = (text) => {
                setFeedback(text);
                setTimeout(() => setFeedback(null), 3000);
            };

            const feed = () => {
                if (petStatus === 'dead' || petStatus === 'sleeping') return;
                setStats(s => ({ ...s, hunger: Math.min(100, s.hunger + 20) }));
                setPetStatus('eating');
                showFloatingText("üçî Yummy!");
                setTimeout(() => setPetStatus('idle'), 2000);
            };

            const play = () => {
                if (petStatus === 'dead' || petStatus === 'sleeping') return;
                setStats(s => ({ ...s, fun: Math.min(100, s.fun + 20), energy: Math.max(0, s.energy - 8) }));
                setPetStatus('playing');
                showFloatingText("üéæ Yay!");
                setTimeout(() => setPetStatus('idle'), 2000);
            };

            const sleep = () => {
                if (petStatus === 'dead') return;
                setPetStatus('sleeping');
                showFloatingText("üí§ Nap time");
            };
            
            const revive = () => {
                 setStats({ hunger: 60, fun: 60, energy: 60 });
                 setPetStatus('idle');
                 showFloatingText("‚ú® REVIVED!");
            }

            // --- TWITCH ---
            const connect = useCallback(() => {
                if (!channel) return;
                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
                ws.current = socket;

                socket.onopen = () => {
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan123');
                    socket.send(`JOIN #${channel.toLowerCase()}`);
                };

                socket.onmessage = (event) => {
                    const data = event.data;
                    if (data.startsWith('PING')) { socket.send('PONG :tmi.twitch.tv'); return; }
                    if (!data.includes('PRIVMSG')) return;

                    const parts = data.split(' ');
                    const msgIdx = parts.indexOf('PRIVMSG');
                    if (msgIdx === -1) return;

                    let message = parts.slice(msgIdx + 2).join(' ');
                    if (message.startsWith(':')) message = message.substring(1);
                    message = message.trim().toLowerCase();

                    if (message.startsWith('!feed')) feed();
                    if (message.startsWith('!play') || message.startsWith('!pet')) play();
                    if (message.startsWith('!sleep')) sleep();
                    if (message.startsWith('!revive') && petStatus === 'dead') revive();
                };

                socket.onclose = () => { setTimeout(connect, 5000); };
            }, [channel, petStatus]);

            useEffect(() => {
                if (channel) {
                    localStorage.setItem('pet_channel', channel);
                    connect();
                }
                return () => { if (ws.current) ws.current.close(); };
            }, [connect, channel]);

            if (!channel) {
                return (
                    <div className="flex items-center justify-center h-full">
                        <div className="bg-gray-800 p-8 rounded-xl shadow-2xl w-80">
                            <h1 className="text-2xl font-bold mb-4">Streamagochi Setup</h1>
                            <input className="w-full bg-gray-700 p-2 rounded mb-4" placeholder="Twitch Channel" id="setupChannel" />
                            <button onClick={() => {
                                const val = document.getElementById('setupChannel').value;
                                if(val) window.location.search = `?channel=${val}&mode=peek`;
                            }} className="bg-purple-600 w-full py-2 rounded font-bold">Start Peek Mode</button>
                            <p className="text-xs text-gray-400 mt-4 text-center">Pet appears randomly and when commands are used.</p>
                        </div>
                    </div>
                )
            }

            const visible = isPeeking || forceVisible;

            return (
                <div className="w-full h-full relative">
                    
                    {/* Countdown Debugger */}
                    {mode === 'peek' && !visible && nextPeekTime && (
                        <div className="absolute bottom-4 right-4 text-white/30 font-mono text-[10px] bg-black/20 px-2 py-1 rounded">
                            T- {timeRemaining}
                        </div>
                    )}

                    <div 
                        className={`fade-container ${visible ? 'opacity-100' : 'opacity-0'}`}
                        style={{ 
                            left: `${pos.x}%`, 
                            top: `${pos.y}%`, 
                            transform: 'translate(-50%, -50%)',
                            pointerEvents: visible ? 'auto' : 'none'
                        }}
                    >
                        {/* Feedback Text */}
                        {feedback && (
                            <div className="absolute -top-12 left-1/2 -translate-x-1/2 text-lg font-bold text-white drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)] animate-bounce whitespace-nowrap">
                                {feedback}
                            </div>
                        )}

                        <div className="flex flex-col items-center">
                            {/* Status UI */}
                            <div className={`bg-black/60 backdrop-blur-sm p-2 rounded-lg w-32 mb-2 transition-opacity duration-500 ${petStatus === 'dead' ? 'opacity-0' : 'opacity-100'}`}>
                                <StatusBar icon="üçó" value={stats.hunger} color="#10b981" />
                                <StatusBar icon="üòä" value={stats.fun} color="#3b82f6" />
                                <StatusBar icon="‚ö°" value={stats.energy} color="#f59e0b" />
                            </div>

                            <PetBlob status={petStatus} color={DEFAULT_CONFIG.color} isCritical={isCritical} />

                            {petStatus === 'dead' && (
                                <div className="mt-2 bg-red-900/80 p-2 rounded text-center scale-75">
                                    <p className="text-xs font-bold whitespace-nowrap">!revive</p>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
