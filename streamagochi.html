<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Streamagochi</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        
        /* Force transparency */
        .obs-transparent { 
            background-color: transparent !important; 
            background: transparent !important;
        }

        /* Smooth Fade Transition */
        .fade-container {
            transition: opacity 1s ease-in-out;
        }
        
        /* Blob Animations */
        @keyframes breathe { 0%, 100% { transform: scale(1); border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; } 50% { transform: scale(1.05); border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; } }
        @keyframes jump { 0%, 100% { transform: translateY(0) scale(1); } 50% { transform: translateY(-20px) scale(0.9); } }
        @keyframes shake { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(-10deg); } 75% { transform: rotate(10deg); } }
        @keyframes sleep { 0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.8; } 50% { transform: scale(0.95) rotate(1deg); opacity: 0.6; } }

        .blob { width: 150px; height: 150px; background: var(--pet-color, #ff6b6b); border: 4px solid rgba(0,0,0,0.2); position: relative; transition: all 0.5s ease; box-shadow: inset -10px -10px 20px rgba(0,0,0,0.1); }
        .blob-face { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 60%; display: flex; justify-content: space-between; align-items: center; }
        .eye { width: 15px; height: 15px; background: #333; border-radius: 50%; animation: blink 4s infinite; }
        .mouth { width: 20px; height: 10px; border-bottom: 3px solid #333; border-radius: 50%; }
        @keyframes blink { 0%, 96%, 100% { transform: scaleY(1); } 98% { transform: scaleY(0.1); } }
        
        /* Status Bar Styles */
        .status-bar-bg { background: rgba(0,0,0,0.5); height: 8px; border-radius: 4px; overflow: hidden; width: 100%; }
        .status-fill { height: 100%; transition: width 0.5s, background-color 0.5s; }

        .anim-idle { animation: breathe 4s infinite ease-in-out; }
        .anim-eat { animation: shake 0.5s infinite; }
        .anim-happy { animation: jump 0.5s infinite; }
        .anim-sleep { animation: sleep 3s infinite ease-in-out; }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen w-screen flex flex-col items-center justify-center">

    <div id="root" class="w-full h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- CONFIGURATION ---
        const PEEK_MIN_MS = 30 * 60 * 1000; // 30 Minutes
        const PEEK_MAX_MS = 60 * 60 * 1000; // 60 Minutes
        const PEEK_DURATION_MS = 8000; // Visible for 8 seconds
        const DECAY_RATE_MS = 5000; 
        const SAVE_INTERVAL_MS = 10000;
        const CRITICAL_THRESHOLD = 20;
        
        const DEFAULT_CONFIG = {
            petName: 'Glitch',
            color: '#a78bfa',
            maxStat: 100
        };

        // --- COMPONENTS ---
        const StatusBar = ({ icon, value, color }) => (
            <div className="flex items-center space-x-2 w-full mb-1">
                <span className="text-lg">{icon}</span>
                <div className="flex-1 flex flex-col">
                    <div className="status-bar-bg">
                        <div className="status-fill" style={{ width: `${value}%`, backgroundColor: value < 30 ? '#ef4444' : color }}></div>
                    </div>
                </div>
            </div>
        );

        const PetBlob = ({ status, color }) => {
            let animClass = "anim-idle";
            let mouthStyle = {};
            let eyeStyle = {};

            if (status === 'eating') {
                animClass = "anim-eat";
                mouthStyle = { height: '20px', borderRadius: '50%', background: '#333' };
            } else if (status === 'playing') {
                animClass = "anim-happy";
                mouthStyle = { borderBottom: '3px solid #333', transform: 'scale(1.2)' };
            } else if (status === 'sleeping') {
                animClass = "anim-sleep";
                eyeStyle = { height: '2px', borderRadius: '0', transform: 'scaleY(1)' };
                mouthStyle = { width: '10px', height: '10px', borderRadius: '50%', border: '2px solid #333' };
            } else if (status === 'dead') {
                animClass = "";
                eyeStyle = { transform: 'rotate(45deg)', borderRadius: '0', height: '2px', width: '15px' };
            }

            return (
                <div className={`blob ${animClass}`} style={{ '--pet-color': color }}>
                    <div className="blob-face">
                        <div className="eye" style={eyeStyle}></div>
                        <div className="mouth" style={mouthStyle}></div>
                        <div className="eye" style={eyeStyle}></div>
                    </div>
                    {status === 'sleeping' && <div className="absolute -top-10 right-0 text-2xl font-bold text-white animate-bounce">Zzz...</div>}
                </div>
            );
        };

        function App() {
            // Helpers
            const getParam = (key) => new URLSearchParams(window.location.search).get(key);
            
            // Config from URL
            const channel = getParam('channel') || localStorage.getItem('pet_channel') || '';
            const mode = getParam('mode') || 'fixed'; // 'fixed' (default) or 'peek'

            // State
            const [stats, setStats] = useState(() => {
                const saved = localStorage.getItem('pet_stats');
                return saved ? JSON.parse(saved) : { hunger: 80, fun: 80, energy: 80 };
            });
            const [petStatus, setPetStatus] = useState('idle');
            const [feedback, setFeedback] = useState(null);
            
            // Visibility State
            const [isPeeking, setIsPeeking] = useState(false);
            const [forceVisible, setForceVisible] = useState(false);
            const [nextPeekTime, setNextPeekTime] = useState(null);
            const [timeRemaining, setTimeRemaining] = useState('');

            // Refs
            const ws = useRef(null);
            const peekTimeoutRef = useRef(null);
            const hideTimeoutRef = useRef(null);

            // --- PEEK LOGIC ---
            useEffect(() => {
                if (!channel || mode !== 'peek') return;

                const scheduleNextPeek = () => {
                    const delay = Math.floor(Math.random() * (PEEK_MAX_MS - PEEK_MIN_MS) + PEEK_MIN_MS);
                    setNextPeekTime(Date.now() + delay);
                    
                    peekTimeoutRef.current = setTimeout(() => {
                        setIsPeeking(true);
                        hideTimeoutRef.current = setTimeout(() => {
                            setIsPeeking(false);
                            scheduleNextPeek();
                        }, PEEK_DURATION_MS);
                    }, delay);
                };

                scheduleNextPeek();

                return () => {
                    clearTimeout(peekTimeoutRef.current);
                    clearTimeout(hideTimeoutRef.current);
                };
            }, [channel, mode]);

            // --- COUNTDOWN TIMER (Only for Peek Mode) ---
            useEffect(() => {
                if (mode !== 'peek' || !nextPeekTime) return;
                
                const interval = setInterval(() => {
                    const diff = nextPeekTime - Date.now();
                    if (diff <= 0) {
                        setTimeRemaining("Soon...");
                    } else {
                        const mins = Math.floor(diff / 60000);
                        const secs = Math.floor((diff % 60000) / 1000);
                        setTimeRemaining(`${mins}m ${secs}s`);
                    }
                }, 1000);
                return () => clearInterval(interval);
            }, [nextPeekTime, mode]);

            // --- VISIBILITY CHECK ---
            useEffect(() => {
                if (mode === 'fixed') {
                    setForceVisible(true);
                    return;
                }

                const isCritical = stats.hunger < CRITICAL_THRESHOLD || stats.fun < CRITICAL_THRESHOLD || stats.energy < CRITICAL_THRESHOLD;
                const isInteracting = petStatus === 'eating' || petStatus === 'playing';
                const isDead = petStatus === 'dead';

                if (isCritical || isInteracting || isDead) {
                    setForceVisible(true);
                } else {
                    setForceVisible(false);
                }
            }, [stats, petStatus, mode]);

            // --- TRANSPARENCY ---
            useEffect(() => {
                if (channel) {
                    document.body.classList.add('obs-transparent');
                    document.body.classList.remove('bg-gray-900');
                } else {
                    document.body.classList.remove('obs-transparent');
                    document.body.classList.add('bg-gray-900');
                }
            }, [channel]);

            // --- STATS LOOP ---
            useEffect(() => {
                const interval = setInterval(() => {
                    localStorage.setItem('pet_stats', JSON.stringify(stats));
                }, SAVE_INTERVAL_MS);
                
                if (petStatus === 'dead') return () => clearInterval(interval);

                const decay = setInterval(() => {
                    setStats(curr => {
                        let { hunger, fun, energy } = curr;
                        if (petStatus === 'sleeping') {
                            energy = Math.min(100, energy + 5);
                            hunger = Math.max(0, hunger - 2);
                            if (energy >= 100) setPetStatus('idle');
                        } else {
                            hunger = Math.max(0, hunger - 1);
                            fun = Math.max(0, fun - 1);
                            energy = Math.max(0, energy - 0.5);
                        }
                        if (hunger === 0) setPetStatus('dead');
                        return { hunger, fun, energy };
                    });
                }, DECAY_RATE_MS);

                return () => { clearInterval(interval); clearInterval(decay); };
            }, [petStatus]);

            // --- COMMANDS ---
            const showFloatingText = (text) => {
                setFeedback(text);
                if(mode === 'peek') setForceVisible(true); 
                setTimeout(() => {
                    setFeedback(null);
                    if(mode === 'peek') setForceVisible(false);
                }, 3000);
            };

            const feed = () => {
                if (petStatus === 'dead' || petStatus === 'sleeping') return;
                setStats(s => ({ ...s, hunger: Math.min(100, s.hunger + 15) }));
                setPetStatus('eating');
                showFloatingText("ðŸ” Yummy!");
                setTimeout(() => setPetStatus('idle'), 2000);
            };

            const play = () => {
                if (petStatus === 'dead' || petStatus === 'sleeping') return;
                setStats(s => ({ ...s, fun: Math.min(100, s.fun + 15), energy: Math.max(0, s.energy - 5) }));
                setPetStatus('playing');
                showFloatingText("ðŸŽ¾ Yay!");
                setTimeout(() => setPetStatus('idle'), 2000);
            };

            const sleep = () => {
                if (petStatus === 'dead') return;
                setPetStatus('sleeping');
                showFloatingText("ðŸ’¤ Nap time");
            };
            
            const revive = () => {
                 setStats({ hunger: 50, fun: 50, energy: 50 });
                 setPetStatus('idle');
                 showFloatingText("âœ¨ REVIVED!");
            }

            // --- TWITCH ---
            const connect = useCallback(() => {
                if (!channel) return;
                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
                ws.current = socket;

                socket.onopen = () => {
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan12345');
                    socket.send(`JOIN #${channel.toLowerCase()}`);
                };

                socket.onmessage = (event) => {
                    const data = event.data;
                    if (data.startsWith('PING')) { socket.send('PONG :tmi.twitch.tv'); return; }
                    if (!data.includes('PRIVMSG')) return;

                    const parts = data.split(' ');
                    const msgIdx = parts.indexOf('PRIVMSG');
                    if (msgIdx === -1) return;

                    let message = parts.slice(msgIdx + 2).join(' ');
                    if (message.startsWith(':')) message = message.substring(1);
                    message = message.trim().toLowerCase();

                    if (message.startsWith('!feed')) feed();
                    if (message.startsWith('!play') || message.startsWith('!pet')) play();
                    if (message.startsWith('!sleep')) sleep();
                    if (message.startsWith('!revive') && petStatus === 'dead') revive();
                };

                socket.onclose = () => {
                    setTimeout(connect, 5000); 
                };
            }, [channel, petStatus]);

            useEffect(() => {
                if (channel) {
                    localStorage.setItem('pet_channel', channel);
                    connect();
                }
                return () => { if (ws.current) ws.current.close(); };
            }, [connect, channel]);

            // --- RENDER ---
            
            if (!channel) {
                return (
                    <div className="bg-gray-800 p-8 rounded-xl shadow-2xl">
                        <h1 className="text-2xl font-bold mb-4">Streamagochi Setup</h1>
                        <input className="w-full bg-gray-700 p-2 rounded mb-4" placeholder="Channel Name" id="setupChannel" />
                        <button onClick={() => {
                            const val = document.getElementById('setupChannel').value;
                            if(val) window.location.search = `?channel=${val}`;
                        }} className="bg-purple-600 w-full py-2 rounded font-bold">Start</button>
                    </div>
                )
            }

            const visible = isPeeking || forceVisible;

            return (
                <div className="relative flex flex-col items-center justify-end h-full w-full">
                    
                    {/* Countdown (Peek Mode Only) */}
                    {mode === 'peek' && !visible && nextPeekTime && (
                        <div className="absolute top-10 text-white/50 font-mono text-sm bg-black/30 px-3 py-1 rounded-full backdrop-blur-sm">
                            Next visit in: {timeRemaining}
                        </div>
                    )}

                    <div className={`flex flex-col items-center justify-end pb-4 w-64 fade-container ${visible ? 'opacity-100' : 'opacity-0'}`}>
                        {/* Status UI */}
                        <div className={`bg-gray-900/80 p-2 rounded-lg w-full mb-4 transition-opacity duration-500 ${petStatus === 'dead' ? 'opacity-0' : 'opacity-100'}`}>
                            <div className="flex justify-between text-xs text-gray-400 mb-1">
                                <span>{DEFAULT_CONFIG.petName}</span>
                                <span>Lv. 1</span>
                            </div>
                            <StatusBar icon="ðŸ—" value={stats.hunger} color="#10b981" />
                            <StatusBar icon="ðŸ˜Š" value={stats.fun} color="#3b82f6" />
                            <StatusBar icon="âš¡" value={stats.energy} color="#f59e0b" />
                        </div>

                        {feedback && (
                            <div className="absolute top-10 text-2xl font-bold text-white drop-shadow-md animate-bounce">
                                {feedback}
                            </div>
                        )}

                        <PetBlob status={petStatus} color={DEFAULT_CONFIG.color} />

                        {petStatus === 'dead' && (
                            <div className="absolute top-1/2 bg-black/80 p-4 rounded text-center">
                                <h2 className="text-red-500 font-bold text-xl">OH NO!</h2>
                                <p className="text-sm">Type !revive</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
