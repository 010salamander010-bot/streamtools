<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Streamagochi</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { font-family: 'Segoe UI', sans-serif; overflow: hidden; margin: 0; padding: 0; width: 100vw; height: 100vh; }
        
        /* Force transparency */
        .obs-transparent { 
            background-color: transparent !important; 
            background: transparent !important;
            background-image: none !important;
        }

        /* Slide Transitions for Peeking */
        .peek-container {
            position: absolute;
            transition: transform 1s cubic-bezier(0.34, 1.56, 0.64, 1); /* Bouncy effect */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Positioning Styles */
        /* Left: Hidden (-100% X), Visible (-30% X) */
        .side-left { left: 0; top: 50%; transform: translate(-100%, -50%); flex-direction: row; }
        .side-left.visible { transform: translate(-30%, -50%); }

        /* Right: Hidden (100% X), Visible (30% X) */
        .side-right { right: 0; top: 50%; transform: translate(100%, -50%); flex-direction: row-reverse; }
        .side-right.visible { transform: translate(30%, -50%); }

        /* Bottom: Hidden (100% Y), Visible (30% Y) */
        .side-bottom { bottom: 0; left: 50%; transform: translate(-50%, 100%); flex-direction: column-reverse; }
        .side-bottom.visible { transform: translate(-50%, 30%); }

        /* Fixed Mode Center */
        .mode-fixed { bottom: 0; left: 50%; transform: translate(-50%, 0); flex-direction: column-reverse; transition: opacity 0.5s; }

        
        /* Blob Animations */
        @keyframes breathe { 0%, 100% { transform: scale(1); border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; } 50% { transform: scale(1.05); border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; } }
        @keyframes jump { 0%, 100% { transform: translateY(0) scale(1); } 50% { transform: translateY(-20px) scale(0.9); } }
        @keyframes shake { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(-10deg); } 75% { transform: rotate(10deg); } }
        @keyframes sleep { 0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.8; } 50% { transform: scale(0.95) rotate(1deg); opacity: 0.6; } }

        .blob { width: 150px; height: 150px; background: var(--pet-color, #ff6b6b); border: 4px solid rgba(0,0,0,0.2); position: relative; transition: all 0.5s ease; box-shadow: inset -10px -10px 20px rgba(0,0,0,0.1); }
        .blob-face { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 60%; display: flex; justify-content: space-between; align-items: center; }
        .eye { width: 15px; height: 15px; background: #333; border-radius: 50%; animation: blink 4s infinite; }
        .mouth { width: 20px; height: 10px; border-bottom: 3px solid #333; border-radius: 50%; }
        @keyframes blink { 0%, 96%, 100% { transform: scaleY(1); } 98% { transform: scaleY(0.1); } }
        
        /* Status Bar Styles */
        .status-bar-bg { background: rgba(0,0,0,0.5); height: 8px; border-radius: 4px; overflow: hidden; width: 100%; }
        .status-fill { height: 100%; transition: width 0.5s, background-color 0.5s; }

        .anim-idle { animation: breathe 4s infinite ease-in-out; }
        .anim-eat { animation: shake 0.5s infinite; }
        .anim-happy { animation: jump 0.5s infinite; }
        .anim-sleep { animation: sleep 3s infinite ease-in-out; }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen w-screen flex flex-col items-center justify-center">

    <div id="root" class="w-full h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- CONFIGURATION ---
        const DEFAULT_CONFIG = {
            petName: 'Glitch',
            color: '#a78bfa',
            maxStat: 100
        };

        // --- COMPONENTS ---
        const StatusBar = ({ icon, value, color }) => (
            <div className="flex items-center space-x-2 w-full mb-1">
                <span className="text-lg">{icon}</span>
                <div className="flex-1 flex flex-col">
                    <div className="status-bar-bg">
                        <div className="status-fill" style={{ width: `${value}%`, backgroundColor: value < 30 ? '#ef4444' : color }}></div>
                    </div>
                </div>
            </div>
        );

        const PetBlob = ({ status, color }) => {
            let animClass = "anim-idle";
            let mouthStyle = {};
            let eyeStyle = {};

            if (status === 'eating') {
                animClass = "anim-eat";
                mouthStyle = { height: '20px', borderRadius: '50%', background: '#333' };
            } else if (status === 'playing') {
                animClass = "anim-happy";
                mouthStyle = { borderBottom: '3px solid #333', transform: 'scale(1.2)' };
            } else if (status === 'sleeping') {
                animClass = "anim-sleep";
                eyeStyle = { height: '2px', borderRadius: '0', transform: 'scaleY(1)' };
                mouthStyle = { width: '10px', height: '10px', borderRadius: '50%', border: '2px solid #333' };
            } else if (status === 'dead') {
                animClass = "";
                eyeStyle = { transform: 'rotate(45deg)', borderRadius: '0', height: '2px', width: '15px' };
            }

            return (
                <div className={`blob ${animClass}`} style={{ '--pet-color': color }}>
                    <div className="blob-face">
                        <div className="eye" style={eyeStyle}></div>
                        <div className="mouth" style={mouthStyle}></div>
                        <div className="eye" style={eyeStyle}></div>
                    </div>
                    {status === 'sleeping' && <div className="absolute -top-10 right-0 text-2xl font-bold text-white animate-bounce">Zzz...</div>}
                </div>
            );
        };

        function App() {
            // Helpers
            const getParam = (key) => new URLSearchParams(window.location.search).get(key);
            
            // Config from URL
            const channel = getParam('channel') || localStorage.getItem('pet_channel') || '';
            const isTest = getParam('test') === 'true'; // Check for ?test=true
            
            // Normalize 'mode' param to handle 'peak' typo
            let modeParam = getParam('mode');
            if (modeParam === 'peak') modeParam = 'peek'; // Fix common typo
            const mode = modeParam === 'peek' ? 'peek' : 'fixed';

            // TIMING CONFIG (Dynamic based on test mode)
            const PEEK_MIN_MS = isTest ? 5000 : 30 * 60 * 1000; // 5 seconds in test, 30 mins normally
            const PEEK_MAX_MS = isTest ? 10000 : 60 * 60 * 1000; // 10 seconds in test, 60 mins normally
            const PEEK_DURATION_MS = isTest ? 5000 : 8000; // 5 seconds visible in test
            const DECAY_RATE_MS = 5000; 
            const SAVE_INTERVAL_MS = 10000;
            const CRITICAL_THRESHOLD = 20;

            // State
            const [stats, setStats] = useState(() => {
                const saved = localStorage.getItem('pet_stats');
                return saved ? JSON.parse(saved) : { hunger: 80, fun: 80, energy: 80 };
            });
            const [petStatus, setPetStatus] = useState('idle');
            const [feedback, setFeedback] = useState(null);
            
            // Visibility State
            const [isPeeking, setIsPeeking] = useState(false);
            const [peekSide, setPeekSide] = useState('bottom'); // 'left', 'right', 'bottom'
            const [peekId, setPeekId] = useState(0); // Unique ID for every peek to force remount
            const [forceVisible, setForceVisible] = useState(false);
            const [visibilityReason, setVisibilityReason] = useState(''); // Text for speech bubble
            const [nextPeekTime, setNextPeekTime] = useState(null);
            const [timeRemaining, setTimeRemaining] = useState('');

            // Refs
            const ws = useRef(null);
            const peekTimeoutRef = useRef(null);
            const hideTimeoutRef = useRef(null);

            // --- PEEK LOGIC ---
            useEffect(() => {
                if (!channel || mode !== 'peek') return;

                const scheduleNextPeek = () => {
                    const delay = Math.floor(Math.random() * (PEEK_MAX_MS - PEEK_MIN_MS) + PEEK_MIN_MS);
                    setNextPeekTime(Date.now() + delay);
                    
                    peekTimeoutRef.current = setTimeout(() => {
                        // Pick random side & New ID
                        const sides = ['left', 'right', 'bottom'];
                        const randomSide = sides[Math.floor(Math.random() * sides.length)];
                        setPeekSide(randomSide);
                        setPeekId(Date.now()); // FORCE RE-RENDER with new Key
                        
                        console.log(`[Streamagochi] Peeking from ${randomSide}!`);
                        
                        // Tiny delay to ensure DOM updates to new side's hidden position before animating in
                        setTimeout(() => {
                            setIsPeeking(true);
                        }, 100); // Increased delay slightly for safety

                        // Schedule Hide
                        hideTimeoutRef.current = setTimeout(() => {
                            setIsPeeking(false);
                            scheduleNextPeek();
                        }, PEEK_DURATION_MS + 100);
                        
                    }, delay);
                };

                scheduleNextPeek();

                return () => {
                    clearTimeout(peekTimeoutRef.current);
                    clearTimeout(hideTimeoutRef.current);
                };
            }, [channel, mode, PEEK_MIN_MS, PEEK_MAX_MS, PEEK_DURATION_MS]);

            // --- COUNTDOWN TIMER (Only for Peek Mode) ---
            useEffect(() => {
                if (mode !== 'peek' || !nextPeekTime) return;
                
                const interval = setInterval(() => {
                    const diff = nextPeekTime - Date.now();
                    if (diff <= 0) {
                        setTimeRemaining("Soon...");
                    } else {
                        const mins = Math.floor(diff / 60000);
                        const secs = Math.floor((diff % 60000) / 1000);
                        setTimeRemaining(`${mins}m ${secs}s`);
                    }
                }, 1000);
                return () => clearInterval(interval);
            }, [nextPeekTime, mode]);

            // --- VISIBILITY CHECK ---
            useEffect(() => {
                if (mode === 'fixed') {
                    setForceVisible(true);
                    return;
                }

                // In Peek Mode: We only force visible for INTERACTIONS, not just low stats.
                // Low stats will show a speech bubble only when it naturally peeks.
                
                const isHungry = stats.hunger < CRITICAL_THRESHOLD;
                const isBored = stats.fun < CRITICAL_THRESHOLD;
                const isTired = stats.energy < CRITICAL_THRESHOLD;
                const isInteracting = petStatus === 'eating' || petStatus === 'playing';
                const isDead = petStatus === 'dead';

                // Set Bubble Text (Always ready for when it DOES peek)
                if (isDead) {
                    setVisibilityReason('ðŸ’€ !revive');
                } else if (isHungry) {
                    setVisibilityReason('ðŸ— Hungry!');
                } else if (isBored) {
                    setVisibilityReason('ðŸŽ¾ Bored!');
                } else if (isTired) {
                    setVisibilityReason('ðŸ’¤ Tired!');
                } else {
                    setVisibilityReason('');
                }

                // Only force visible if User is Interacting (Feeding/Playing)
                if (isInteracting) {
                    setForceVisible(true);
                } else {
                    setForceVisible(false);
                }
            }, [stats, petStatus, mode]);

            // --- TRANSPARENCY ---
            useEffect(() => {
                if (channel) {
                    document.body.classList.add('obs-transparent');
                    document.body.classList.remove('bg-gray-900');
                } else {
                    document.body.classList.remove('obs-transparent');
                    document.body.classList.add('bg-gray-900');
                }
            }, [channel]);

            // --- STATS LOOP ---
            useEffect(() => {
                const interval = setInterval(() => {
                    localStorage.setItem('pet_stats', JSON.stringify(stats));
                }, SAVE_INTERVAL_MS);
                
                if (petStatus === 'dead') return () => clearInterval(interval);

                const decay = setInterval(() => {
                    setStats(curr => {
                        let { hunger, fun, energy } = curr;
                        if (petStatus === 'sleeping') {
                            energy = Math.min(100, energy + 5);
                            hunger = Math.max(0, hunger - 2);
                            if (energy >= 100) setPetStatus('idle');
                        } else {
                            hunger = Math.max(0, hunger - 1);
                            fun = Math.max(0, fun - 1);
                            energy = Math.max(0, energy - 0.5);
                        }
                        if (hunger === 0) setPetStatus('dead');
                        return { hunger, fun, energy };
                    });
                }, DECAY_RATE_MS);

                return () => { clearInterval(interval); clearInterval(decay); };
            }, [petStatus]);

            // --- COMMANDS ---
            const showFloatingText = (text) => {
                setFeedback(text);
                if(mode === 'peek') {
                    // Temporarily show for feedback if hidden
                    if (!isPeeking && !forceVisible) {
                        setPeekSide('bottom'); 
                        setForceVisible(true);
                        setTimeout(() => setForceVisible(false), 3000);
                    }
                }
                setTimeout(() => setFeedback(null), 3000);
            };

            const feed = () => {
                if (petStatus === 'dead' || petStatus === 'sleeping') return;
                setStats(s => ({ ...s, hunger: Math.min(100, s.hunger + 15) }));
                setPetStatus('eating');
                showFloatingText("ðŸ” Yummy!");
                setTimeout(() => setPetStatus('idle'), 2000);
            };

            const play = () => {
                if (petStatus === 'dead' || petStatus === 'sleeping') return;
                setStats(s => ({ ...s, fun: Math.min(100, s.fun + 15), energy: Math.max(0, s.energy - 5) }));
                setPetStatus('playing');
                showFloatingText("ðŸŽ¾ Yay!");
                setTimeout(() => setPetStatus('idle'), 2000);
            };

            const sleep = () => {
                if (petStatus === 'dead') return;
                setPetStatus('sleeping');
                showFloatingText("ðŸ’¤ Nap time");
            };
            
            const revive = () => {
                 setStats({ hunger: 50, fun: 50, energy: 50 });
                 setPetStatus('idle');
                 showFloatingText("âœ¨ REVIVED!");
            }

            // --- RESET LOGIC ---
            const resetStats = () => {
                const newStats = { hunger: 100, fun: 100, energy: 100 };
                setStats(newStats);
                setPetStatus('idle');
                localStorage.setItem('pet_stats', JSON.stringify(newStats));
            };

            // --- TWITCH ---
            const connect = useCallback(() => {
                if (!channel) return;
                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
                ws.current = socket;

                socket.onopen = () => {
                    socket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan12345');
                    socket.send(`JOIN #${channel.toLowerCase()}`);
                    setConnected(true);
                };

                socket.onmessage = (event) => {
                    const data = event.data;
                    if (data.startsWith('PING')) { socket.send('PONG :tmi.twitch.tv'); return; }
                    if (!data.includes('PRIVMSG')) return;

                    const parts = data.split(' ');
                    const msgIdx = parts.indexOf('PRIVMSG');
                    if (msgIdx === -1) return;

                    let message = parts.slice(msgIdx + 2).join(' ');
                    if (message.startsWith(':')) message = message.substring(1);
                    message = message.trim().toLowerCase();

                    if (message.startsWith('!feed')) feed();
                    if (message.startsWith('!play') || message.startsWith('!pet')) play();
                    if (message.startsWith('!sleep')) sleep();
                    if (message.startsWith('!revive') && petStatus === 'dead') revive();
                };

                socket.onclose = () => {
                    setTimeout(connect, 5000); 
                };
            }, [channel, petStatus]);

            useEffect(() => {
                if (channel) {
                    localStorage.setItem('pet_channel', channel);
                    connect();
                }
                return () => { if (ws.current) ws.current.close(); };
            }, [connect, channel]);

            // --- RENDER ---
            
            if (!channel) {
                return (
                    <div className="bg-gray-800 p-8 rounded-xl shadow-2xl flex flex-col items-center">
                        <h1 className="text-2xl font-bold mb-4">Streamagochi Setup</h1>
                        <input className="w-full bg-gray-700 p-2 rounded mb-4" placeholder="Channel Name" id="setupChannel" />
                        <div className="flex space-x-2 w-full">
                            <button onClick={() => {
                                const val = document.getElementById('setupChannel').value;
                                if(val) window.location.search = `?channel=${val}`;
                            }} className="bg-purple-600 flex-1 py-2 rounded font-bold">Start</button>
                            <button onClick={resetStats} className="bg-red-600 px-4 py-2 rounded font-bold text-sm">Reset Stats</button>
                        </div>
                    </div>
                )
            }

            const visible = isPeeking || forceVisible;
            const containerClass = `peek-container ${mode === 'peek' ? `side-${peekSide}` : 'mode-fixed'} ${visible ? 'visible' : ''}`;

            return (
                <>
                    {/* Countdown Timer (Only visible when pet is hidden AND in peek mode) */}
                    {mode === 'peek' && !visible && nextPeekTime && (
                        <div className="absolute top-10 left-1/2 -translate-x-1/2 text-white/50 font-mono text-sm bg-black/30 px-3 py-1 rounded-full backdrop-blur-sm transition-opacity hover:opacity-100">
                            {isTest ? "[TEST MODE] " : ""}Next visit in: {timeRemaining}
                        </div>
                    )}

                    {/* Key added to force remount on side change, fixing teleportation */}
                    <div key={mode === 'peek' ? peekId : 'fixed'} className={containerClass}>
                        
                        <div className="relative flex flex-col items-center">
                            {/* Speech Bubble (For warnings/status) - Always show if reason exists */}
                            {visible && visibilityReason && (
                                <div className="bg-white text-black p-2 rounded-lg relative mb-2 font-bold text-sm shadow-lg whitespace-nowrap after:content-[''] after:absolute after:top-full after:left-1/2 after:-translate-x-1/2 after:border-8 after:border-x-transparent after:border-b-transparent after:border-t-white">
                                    {visibilityReason}
                                </div>
                            )}

                            {/* Status UI - Only shown in FIXED mode */}
                            {mode === 'fixed' && (
                                <div className={`bg-gray-900/80 p-2 rounded-lg w-full mb-4 transition-opacity duration-500 ${petStatus === 'dead' ? 'opacity-0' : 'opacity-100'}`}>
                                    <div className="flex justify-between text-xs text-gray-400 mb-1">
                                        <span>{DEFAULT_CONFIG.petName}</span>
                                        <span>Lv. 1</span>
                                    </div>
                                    <StatusBar icon="ðŸ—" value={stats.hunger} color="#10b981" />
                                    <StatusBar icon="ðŸ˜Š" value={stats.fun} color="#3b82f6" />
                                    <StatusBar icon="âš¡" value={stats.energy} color="#f59e0b" />
                                </div>
                            )}

                            {/* Feedback Text */}
                            {feedback && (
                                <div className="absolute -top-16 left-1/2 -translate-x-1/2 text-2xl font-bold text-white drop-shadow-md animate-bounce whitespace-nowrap">
                                    {feedback}
                                </div>
                            )}

                            <PetBlob status={petStatus} color={DEFAULT_CONFIG.color} />

                            {petStatus === 'dead' && mode === 'fixed' && (
                                <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-black/80 p-4 rounded text-center">
                                    <h2 className="text-red-500 font-bold text-xl">OH NO!</h2>
                                    <p className="text-sm">Type !revive</p>
                                </div>
                            )}
                        </div>
                    </div>
                </>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
