<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Streamagochi</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { font-family: 'Segoe UI', sans-serif; overflow: hidden; margin: 0; padding: 0; width: 100vw; height: 100vh; }
        
        .obs-transparent { 
            background-color: transparent !important; 
            background: transparent !important;
        }

        /* The container handles the sliding animation */
        .sliding-container {
            position: fixed;
            transition: all 1s cubic-bezier(0.22, 1, 0.36, 1);
            z-index: 999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        @keyframes breathe { 0%, 100% { transform: scale(1); border-radius: 60% 40% 30% 70% / 60% 30% 70% 40%; } 50% { transform: scale(1.05); border-radius: 30% 60% 70% 40% / 50% 60% 30% 60%; } }
        @keyframes jump { 0%, 100% { transform: translateY(0) scale(1); } 50% { transform: translateY(-20px) scale(0.9); } }
        @keyframes shake { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(-10deg); } 75% { transform: rotate(10deg); } }
        @keyframes sleep { 0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.8; } 50% { transform: scale(0.95) rotate(1deg); opacity: 0.6; } }

        .blob { width: 100px; height: 100px; background: var(--pet-color, #ff6b6b); border: 4px solid rgba(0,0,0,0.2); position: relative; transition: all 0.5s ease; box-shadow: inset -8px -8px 16px rgba(0,0,0,0.15); }
        .blob-face { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 60%; display: flex; justify-content: space-between; align-items: center; }
        .eye { width: 10px; height: 10px; background: #333; border-radius: 50%; animation: blink 4s infinite; }
        .mouth { width: 14px; height: 7px; border-bottom: 3px solid #333; border-radius: 50%; }
        @keyframes blink { 0%, 96%, 100% { transform: scaleY(1); } 98% { transform: scaleY(0.1); } }
        
        .status-bar-bg { background: rgba(0,0,0,0.5); height: 6px; border-radius: 3px; overflow: hidden; width: 100%; }
        .status-fill { height: 100%; transition: width 0.5s, background-color 0.5s; }

        .anim-idle { animation: breathe 4s infinite ease-in-out; }
        .anim-eat { animation: shake 0.5s infinite; }
        .anim-happy { animation: jump 0.5s infinite; }
        .anim-sleep { animation: sleep 3s infinite ease-in-out; }

        .bubble {
            position: absolute;
            top: -45px;
            background: white;
            padding: 4px 10px;
            border-radius: 15px;
            color: black;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            font-size: 1.2rem;
            animation: jump 1.5s infinite;
            z-index: 10;
        }
        .bubble::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid white;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div id="root" class="w-full h-full relative"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- CONFIGURATION ---
        const PEEK_MIN_MS = 60 * 1000; 
        const PEEK_MAX_MS = 180 * 1000; 
        const PEEK_DURATION_MS = 8000; 
        const DECAY_RATE_MS = 5000; 
        const CRITICAL_THRESHOLD = 30;
        
        const DEFAULT_CONFIG = {
            petName: 'Glitch',
            color: '#a78bfa',
            maxStat: 100
        };

        const StatusBar = ({ icon, value, color }) => (
            <div className="flex items-center space-x-2 w-full mb-1">
                <span className="text-xs">{icon}</span>
                <div className="flex-1 flex flex-col">
                    <div className="status-bar-bg">
                        <div className="status-fill" style={{ width: `${value}%`, backgroundColor: value < 30 ? '#ef4444' : color }}></div>
                    </div>
                </div>
            </div>
        );

        const PetBlob = ({ status, color, stats }) => {
            let animClass = "anim-idle";
            let mouthStyle = {};
            let eyeStyle = {};
            let emoji = null;

            // Determine emoji priority
            if (status === 'dead') emoji = "üíÄ";
            else if (status === 'eating') emoji = "üçî";
            else if (status === 'playing') emoji = "üéæ";
            else if (stats.hunger < CRITICAL_THRESHOLD) emoji = "üçî?";
            else if (stats.fun < CRITICAL_THRESHOLD) emoji = "üéæ?";
            else if (stats.energy < CRITICAL_THRESHOLD) emoji = "‚ö°";

            if (status === 'eating') {
                animClass = "anim-eat";
                mouthStyle = { height: '12px', borderRadius: '50%', background: '#333' };
            } else if (status === 'playing') {
                animClass = "anim-happy";
                mouthStyle = { borderBottom: '3px solid #333', transform: 'scale(1.2)' };
            } else if (status === 'sleeping') {
                animClass = "anim-sleep";
                eyeStyle = { height: '2px', borderRadius: '0', transform: 'scaleY(1)' };
                mouthStyle = { width: '8px', height: '8px', borderRadius: '50%', border: '2px solid #333' };
            } else if (status === 'dead') {
                animClass = "";
                eyeStyle = { transform: 'rotate(45deg)', borderRadius: '0', height: '2px', width: '12px' };
            }

            return (
                <div className={`blob ${animClass}`} style={{ '--pet-color': color }}>
                    {emoji && <div className="bubble">{emoji}</div>}
                    <div className="blob-face">
                        <div className="eye" style={eyeStyle}></div>
                        <div className="mouth" style={mouthStyle}></div>
                        <div className="eye" style={eyeStyle}></div>
                    </div>
                    {status === 'sleeping' && <div className="absolute -top-12 left-0 text-xl font-bold text-white animate-pulse">Zzz...</div>}
                </div>
            );
        };

        function App() {
            const getParam = (key) => new URLSearchParams(window.location.search).get(key);
            const channel = getParam('channel') || localStorage.getItem('pet_channel') || '';
            const mode = getParam('mode') || 'fixed'; 

            const [stats, setStats] = useState(() => {
                const saved = localStorage.getItem('pet_stats');
                return saved ? JSON.parse(saved) : { hunger: 80, fun: 80, energy: 80 };
            });
            const [petStatus, setPetStatus] = useState('idle');
            const [feedback, setFeedback] = useState(null);
            
            // Peek State
            const [isVisuallyActive, setIsVisuallyActive] = useState(mode === 'fixed');
            const [peekConfig, setPeekConfig] = useState({ edge: 'bottom', offset: 50 });
            const [nextPeekTime, setNextPeekTime] = useState(null);

            const ws = useRef(null);
            const peekTimeoutRef = useRef(null);
            const hideTimeoutRef = useRef(null);

            // --- POSITIONING LOGIC ---
            const randomizePeek = useCallback(() => {
                const edges = ['top', 'bottom', 'left', 'right'];
                const edge = edges[Math.floor(Math.random() * edges.length)];
                const offset = Math.floor(Math.random() * 60) + 20; // 20% to 80% to avoid corners
                setPeekConfig({ edge, offset });
            }, []);

            const triggerPeek = useCallback(() => {
                if (isVisuallyActive && mode === 'peek') return; // Already visible
                randomizePeek();
                setIsVisuallyActive(true);
                
                if (hideTimeoutRef.current) clearTimeout(hideTimeoutRef.current);
                
                hideTimeoutRef.current = setTimeout(() => {
                    setIsVisuallyActive(false);
                }, PEEK_DURATION_MS);
            }, [isVisuallyActive, mode, randomizePeek]);

            // --- SCHEDULED PEEKS ---
            useEffect(() => {
                if (!channel || mode !== 'peek') return;

                const scheduleNext = () => {
                    const delay = Math.floor(Math.random() * (PEEK_MAX_MS - PEEK_MIN_MS) + PEEK_MIN_MS);
                    setNextPeekTime(Date.now() + delay);
                    
                    peekTimeoutRef.current = setTimeout(() => {
                        triggerPeek();
                        scheduleNext();
                    }, delay);
                };

                scheduleNext();
                return () => {
                    clearTimeout(peekTimeoutRef.current);
                    clearTimeout(hideTimeoutRef.current);
                };
            }, [channel, mode, triggerPeek]);

            // --- CRITICAL AUTO-PEEK ---
            useEffect(() => {
                if (mode !== 'peek') return;
                const isCritical = stats.hunger < CRITICAL_THRESHOLD || stats.fun < CRITICAL_THRESHOLD || stats.energy < CRITICAL_THRESHOLD || petStatus === 'dead';
                
                if (isCritical && !isVisuallyActive) {
                    triggerPeek();
                }
            }, [stats, petStatus, mode, isVisuallyActive, triggerPeek]);

            // --- STYLE CALCULATOR ---
            const getSlidingStyles = () => {
                if (mode === 'fixed') {
                    return { bottom: '20px', left: '50%', transform: 'translateX(-50%)', opacity: 1 };
                }

                const offscreenBuffer = '-150px';
                const onscreenBuffer = '20px';
                const { edge, offset } = peekConfig;

                let styles = { opacity: isVisuallyActive ? 1 : 0 };

                if (edge === 'bottom') {
                    styles.bottom = isVisuallyActive ? onscreenBuffer : offscreenBuffer;
                    styles.left = `${offset}%`;
                    styles.transform = 'translateX(-50%)';
                } else if (edge === 'top') {
                    styles.top = isVisuallyActive ? onscreenBuffer : offscreenBuffer;
                    styles.left = `${offset}%`;
                    styles.transform = 'translateX(-50%)';
                } else if (edge === 'left') {
                    styles.left = isVisuallyActive ? onscreenBuffer : offscreenBuffer;
                    styles.top = `${offset}%`;
                    styles.transform = 'translateY(-50%)';
                } else if (edge === 'right') {
                    styles.right = isVisuallyActive ? onscreenBuffer : offscreenBuffer;
                    styles.top = `${offset}%`;
                    styles.transform = 'translateY(-50%)';
                }

                return styles;
            };

            // --- GAME LOOP ---
            useEffect(() => {
                const decay = setInterval(() => {
                    setStats(curr => {
                        let { hunger, fun, energy } = curr;
                        if (petStatus === 'sleeping') {
                            energy = Math.min(100, energy + 4);
                            hunger = Math.max(0, hunger - 1);
                            if (energy >= 100) setPetStatus('idle');
                        } else {
                            hunger = Math.max(0, hunger - 0.5);
                            fun = Math.max(0, fun - 0.5);
                            energy = Math.max(0, energy - 0.2);
                        }
                        if (hunger <= 0) setPetStatus('dead');
                        return { ...curr, hunger, fun, energy };
                    });
                }, DECAY_RATE_MS);

                const save = setInterval(() => {
                    localStorage.setItem('pet_stats', JSON.stringify(stats));
                }, 10000);

                return () => { clearInterval(decay); clearInterval(save); };
            }, [petStatus, stats]);

            // --- ACTIONS ---
            const showFeedback = (text) => {
                setFeedback(text);
                triggerPeek(); // Always show pet when someone interacts
                setTimeout(() => setFeedback(null), 3000);
            };

            const feed = () => {
                if (petStatus === 'dead' || petStatus === 'sleeping') return;
                setStats(s => ({ ...s, hunger: Math.min(100, s.hunger + 25) }));
                setPetStatus('eating');
                showFeedback("üçî YUM!");
                setTimeout(() => setPetStatus('idle'), 3000);
            };

            const play = () => {
                if (petStatus === 'dead' || petStatus === 'sleeping') return;
                setStats(s => ({ ...s, fun: Math.min(100, s.fun + 25), energy: Math.max(0, s.energy - 10) }));
                setPetStatus('playing');
                showFeedback("üéæ YAY!");
                setTimeout(() => setPetStatus('idle'), 3000);
            };

            const sleep = () => {
                if (petStatus === 'dead') return;
                setPetStatus('sleeping');
                showFeedback("üí§ ZZZ...");
            };

            const revive = () => {
                 setStats({ hunger: 70, fun: 70, energy: 70 });
                 setPetStatus('idle');
                 showFeedback("‚ú® ALIVE!");
            };

            // --- TWITCH ---
            useEffect(() => {
                if (!channel) return;
                const socket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
                socket.onopen = () => {
                    socket.send('CAP REQ :twitch.tv/commands');
                    socket.send('PASS SCHMOOPIIE');
                    socket.send('NICK justinfan123');
                    socket.send(`JOIN #${channel.toLowerCase()}`);
                };
                socket.onmessage = (e) => {
                    const msg = e.data;
                    if (msg.startsWith('PING')) socket.send('PONG :tmi.twitch.tv');
                    const text = msg.split('PRIVMSG')[1]?.split(':').slice(1).join(':').trim().toLowerCase();
                    if (!text) return;

                    if (text.startsWith('!feed')) feed();
                    if (text.startsWith('!play') || text.startsWith('!pet')) play();
                    if (text.startsWith('!sleep')) sleep();
                    if (text.startsWith('!revive')) revive();
                };
                return () => socket.close();
            }, [channel, petStatus]);

            // --- UI ---
            if (!channel) {
                return (
                    <div className="flex items-center justify-center h-full">
                        <div className="bg-gray-800 p-8 rounded-2xl shadow-2xl w-96 border border-purple-500/30">
                            <h1 className="text-3xl font-bold mb-2 text-purple-400">Streamagochi</h1>
                            <p className="text-gray-400 mb-6 text-sm">A tiny friend that peeks into your stream.</p>
                            <input className="w-full bg-gray-900 border border-gray-700 p-3 rounded-lg mb-4 focus:border-purple-500 outline-none" placeholder="Twitch Channel Name" id="c" />
                            <div className="grid grid-cols-2 gap-2">
                                <button onClick={() => window.location.search = `?channel=${document.getElementById('c').value}&mode=peek`} className="bg-purple-600 hover:bg-purple-500 py-3 rounded-lg font-bold transition-colors">Peek Mode</button>
                                <button onClick={() => window.location.search = `?channel=${document.getElementById('c').value}&mode=fixed`} className="bg-gray-700 hover:bg-gray-600 py-3 rounded-lg font-bold transition-colors">Fixed Mode</button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="w-full h-full relative">
                    {/* Floating Pet Container */}
                    <div className="sliding-container" style={getSlidingStyles()}>
                        
                        {/* Status UI - Only visible in fixed mode */}
                        {mode === 'fixed' && (
                            <div className="bg-black/70 backdrop-blur-md p-3 rounded-xl w-36 mb-4 border border-white/10 shadow-xl">
                                <StatusBar icon="üçó" value={stats.hunger} color="#10b981" />
                                <StatusBar icon="üòä" value={stats.fun} color="#3b82f6" />
                                <StatusBar icon="‚ö°" value={stats.energy} color="#f59e0b" />
                            </div>
                        )}

                        {/* Feedback Text (Commands) */}
                        {feedback && (
                            <div className="absolute -top-16 text-xl font-black text-white drop-shadow-[0_4px_4px_rgba(0,0,0,0.8)] animate-bounce text-center w-48">
                                {feedback}
                            </div>
                        )}

                        <PetBlob status={petStatus} color={DEFAULT_CONFIG.color} stats={stats} />
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
